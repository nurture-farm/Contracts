// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Common/enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Common_2fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Common_2fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Common_2fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Common_2fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Common_2fenums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace farm {
namespace nurture {
namespace core {
namespace contracts {
namespace common {

enum EventType : int {
  NO_WORKFLOW = 0,
  EVENT = 1,
  SERVICE = 2,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EventType_IsValid(int value);
constexpr EventType EventType_MIN = NO_WORKFLOW;
constexpr EventType EventType_MAX = SERVICE;
constexpr int EventType_ARRAYSIZE = EventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventType_descriptor();
template<typename T>
inline const std::string& EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventType_descriptor(), enum_t_value);
}
inline bool EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventType>(
    EventType_descriptor(), name, value);
}
enum BookingType : int {
  NO_BOOKING = 0,
  FARM_SERVICE = 1,
  VISIT_FARMER = 2,
  SOIL_TESTING_BOOKING = 3,
  ORCHID_BOOKING = 4,
  PUSA_SPRAY_BOOKING = 5,
  GROUNDNUT_HARVEST_BOOKING = 6,
  SEED_TREATMENT_BOOKING = 7,
  POTATO_PLANTER_BOOKING = 8,
  CULTIVATOR_BOOKING = 9,
  DISC_HARROW_BOOKING = 10,
  ROTAVATOR_BOOKING = 11,
  MB_PLOUGH_BOOKING = 12,
  TRACK_TYPE_COMBINE_HARVESTER_BOOKING = 13,
  COMBINE_HARVESTER_BOOKING = 14,
  SEED_DRILL_BOOKING = 15,
  MANUAL_LEVELER_BOOKING = 16,
  HAPPY_SEEDER_BOOKING = 17,
  SUPER_SEEDER_BOOKING = 18,
  ZERO_SEED_DRILL_BOOKING = 19,
  TROLLEY_BOOKING = 20,
  TRACTOR_CAGE_WHEEL_BOOKING = 21,
  PADDY_RIDGER_BOOKING = 22,
  MULCHER_BOOKING = 23,
  BAILER_BOOKING = 24,
  POWER_TILLER_BOOKING = 25,
  POWER_WEEDER_BOOKING = 26,
  POWER_REAPER_BOOKING = 27,
  SHREDDER_BOOKING = 28,
  POTATO_DIGGER_BOOKING = 29,
  POTATO_HARVESTER_BOOKING = 30,
  PADDY_THRESHER_BOOKING = 31,
  THRESHER_BOOKING = 32,
  STRAW_REAPER_BOOKING = 33,
  GROUNDNUT_DIGGER_BOOKING = 34,
  MANGO_SPRAY_BOOKING = 35,
  LASER_LAND_LEVELLER_BOOKING = 36,
  POMEGRANATE_SPRAYER_BOOKING = 37,
  MAIZE_PLANTING_BOOKING = 38,
  SUGARCANE_PLANTER_BOOKING = 39,
  SOIL_SAMPLING_BOOKING = 40,
  DRONE_SPRAYING_BOOKING = 41,
  SOIL_TESTING_ML_BOOKING = 42,
  SOYBEAN_HARVESTING_BOOKING = 43,
  BookingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BookingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BookingType_IsValid(int value);
constexpr BookingType BookingType_MIN = NO_BOOKING;
constexpr BookingType BookingType_MAX = SOYBEAN_HARVESTING_BOOKING;
constexpr int BookingType_ARRAYSIZE = BookingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BookingType_descriptor();
template<typename T>
inline const std::string& BookingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BookingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BookingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BookingType_descriptor(), enum_t_value);
}
inline bool BookingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BookingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BookingType>(
    BookingType_descriptor(), name, value);
}
enum ServiceType : int {
  NO_SERVICE = 0,
  SOWING = 1,
  SPRAYING = 2,
  HARVESTING = 3,
  SOIL_SAMPLE_COLLECTION = 4,
  SOIL_TESTING_SERVICE = 5,
  PUSA_SPRAY_SERVICE = 6,
  GROUNDNUT_HARVEST_SERVICE = 7,
  SEED_TREATMENT_SERVICE = 8,
  POTATO_PLANTER_SERVICE = 9,
  CULTIVATOR_SERVICE = 10,
  DISC_HARROW_SERVICE = 11,
  ROTAVATOR_SERVICE = 12,
  MB_PLOUGH_SERVICE = 13,
  TRACK_TYPE_COMBINE_HARVESTER_SERVICE = 14,
  COMBINE_HARVESTER_SERVICE = 15,
  SEED_DRILL_SERVICE = 16,
  MANUAL_LEVELER_SERVICE = 17,
  HAPPY_SEEDER_SERVICE = 18,
  SUPER_SEEDER_SERVICE = 19,
  ZERO_SEED_DRILL_SERVICE = 20,
  TROLLEY_SERVICE = 21,
  TRACTOR_CAGE_WHEEL_SERVICE = 22,
  PADDY_RIDGER_SERVICE = 23,
  MULCHER_SERVICE = 24,
  BAILER_SERVICE = 25,
  POWER_TILLER_SERVICE = 26,
  POWER_WEEDER_SERVICE = 27,
  POWER_REAPER_SERVICE = 28,
  SHREDDER_SERVICE = 29,
  POTATO_DIGGER_SERVICE = 30,
  POTATO_HARVESTER_SERVICE = 31,
  PADDY_THRESHER_SERVICE = 32,
  THRESHER_SERVICE = 33,
  STRAW_REAPER_SERVICE = 34,
  GROUNDNUT_DIGGER_SERVICE = 35,
  MANGO_SPRAY_SERVICE = 36,
  LASER_LAND_LEVELLER_SERVICE = 37,
  POMEGRANATE_SPRAYER_SERVICE = 38,
  MAIZE_PLANTING_SERVICE = 39,
  SUGARCANE_PLANTER_SERVICE = 40,
  SOIL_SAMPLING_SERVICE = 41,
  DRONE_SPRAYING_SERVICE = 42,
  SOIL_TESTING_ML_SERVICE = 43,
  SOYBEAN_HARVESTING_SERVICE = 44,
  ServiceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ServiceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ServiceType_IsValid(int value);
constexpr ServiceType ServiceType_MIN = NO_SERVICE;
constexpr ServiceType ServiceType_MAX = SOYBEAN_HARVESTING_SERVICE;
constexpr int ServiceType_ARRAYSIZE = ServiceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceType_descriptor();
template<typename T>
inline const std::string& ServiceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceType_descriptor(), enum_t_value);
}
inline bool ServiceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceType>(
    ServiceType_descriptor(), name, value);
}
enum WorkType : int {
  NO_WORK_TYPE = 0,
  OPERATOR_SOIL_SAMPLE_COLLECTION = 1,
  OPTICS_SOIL_TESTING = 2,
  TRACTOR_SPRAY = 3,
  DRONE_SPRAY = 4,
  VERTICAL_SPRAY = 6,
  HARVEST_WORK = 7,
  HARVESTER_DRIVING_WORK = 8,
  TRACTOR_PUSA_SPRAY = 9,
  SEED_TREATMENT_WORK_TYPE = 10,
  POTATO_PLANTER_WORK_TYPE = 11,
  CULTIVATOR_WORK_TYPE = 12,
  DISC_HARROW_WORK_TYPE = 13,
  ROTAVATOR_WORK_TYPE = 14,
  MB_PLOUGH_WORK_TYPE = 15,
  TRACK_TYPE_COMBINE_HARVESTER_WORK_TYPE = 16,
  COMBINE_HARVESTER_WORK_TYPE = 17,
  SEED_DRILL_WORK_TYPE = 18,
  MANUAL_LEVELER_WORK_TYPE = 19,
  HAPPY_SEEDER_WORK_TYPE = 20,
  SUPER_SEEDER_WORK_TYPE = 21,
  ZERO_SEED_DRILL_WORK_TYPE = 22,
  TROLLEY_WORK_TYPE = 23,
  TRACTOR_CAGE_WHEEL_WORK_TYPE = 24,
  PADDY_RIDGER_WORK_TYPE = 25,
  MULCHER_WORK_TYPE = 26,
  BAILER_WORK_TYPE = 27,
  POWER_TILLER_WORK_TYPE = 28,
  POWER_WEEDER_WORK_TYPE = 29,
  POWER_REAPER_WORK_TYPE = 30,
  SHREDDER_WORK_TYPE = 31,
  POTATO_DIGGER_WORK_TYPE = 32,
  POTATO_HARVESTER_WORK_TYPE = 33,
  PADDY_THRESHER_WORK_TYPE = 34,
  THRESHER_WORK_TYPE = 35,
  STRAW_REAPER_WORK_TYPE = 36,
  GROUNDNUT_DIGGER_WORK_TYPE = 37,
  MANGO_SPRAY_WORK_TYPE = 38,
  LASER_LAND_LEVELLER_WORK_TYPE = 39,
  POMEGRANATE_SPRAYER_WORK_TYPE = 40,
  MAIZE_PLANTING_WORK_TYPE = 41,
  SUGARCANE_PLANTER_WORK_TYPE = 42,
  SOIL_SAMPLING_WORK_TYPE = 43,
  DRONE_SPRAYING_WORK_TYPE = 44,
  SOIL_TESTING_ML_WORK_TYPE = 45,
  SOYBEAN_HARVESTING_WORK_TYPE = 46,
  WorkType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkType_IsValid(int value);
constexpr WorkType WorkType_MIN = NO_WORK_TYPE;
constexpr WorkType WorkType_MAX = SOYBEAN_HARVESTING_WORK_TYPE;
constexpr int WorkType_ARRAYSIZE = WorkType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkType_descriptor();
template<typename T>
inline const std::string& WorkType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkType_descriptor(), enum_t_value);
}
inline bool WorkType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkType>(
    WorkType_descriptor(), name, value);
}
enum WorkClass : int {
  NO_WORK_CLASS = 0,
  INDIAN_TRACTOR_SPRAY = 1,
  WorkClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkClass_IsValid(int value);
constexpr WorkClass WorkClass_MIN = NO_WORK_CLASS;
constexpr WorkClass WorkClass_MAX = INDIAN_TRACTOR_SPRAY;
constexpr int WorkClass_ARRAYSIZE = WorkClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkClass_descriptor();
template<typename T>
inline const std::string& WorkClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkClass_descriptor(), enum_t_value);
}
inline bool WorkClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkClass>(
    WorkClass_descriptor(), name, value);
}
enum ServiceClass : int {
  NO_SERVICE_CLASS = 0,
  OPERATOR_MACHINE_SERVICE = 1,
  ServiceClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ServiceClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ServiceClass_IsValid(int value);
constexpr ServiceClass ServiceClass_MIN = NO_SERVICE_CLASS;
constexpr ServiceClass ServiceClass_MAX = OPERATOR_MACHINE_SERVICE;
constexpr int ServiceClass_ARRAYSIZE = ServiceClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceClass_descriptor();
template<typename T>
inline const std::string& ServiceClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceClass_descriptor(), enum_t_value);
}
inline bool ServiceClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceClass>(
    ServiceClass_descriptor(), name, value);
}
enum UnitType : int {
  NO_UNIT_TYPE = 0,
  UNIT_ACRES = 1,
  UNIT_LITERS = 2,
  UNIT_KGS = 3,
  UnitType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UnitType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UnitType_IsValid(int value);
constexpr UnitType UnitType_MIN = NO_UNIT_TYPE;
constexpr UnitType UnitType_MAX = UNIT_KGS;
constexpr int UnitType_ARRAYSIZE = UnitType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UnitType_descriptor();
template<typename T>
inline const std::string& UnitType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UnitType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UnitType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UnitType_descriptor(), enum_t_value);
}
inline bool UnitType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UnitType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UnitType>(
    UnitType_descriptor(), name, value);
}
enum ProductSKUClass : int {
  PRODUCT_NO_CLASS = 0,
  ProductSKUClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProductSKUClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProductSKUClass_IsValid(int value);
constexpr ProductSKUClass ProductSKUClass_MIN = PRODUCT_NO_CLASS;
constexpr ProductSKUClass ProductSKUClass_MAX = PRODUCT_NO_CLASS;
constexpr int ProductSKUClass_ARRAYSIZE = ProductSKUClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProductSKUClass_descriptor();
template<typename T>
inline const std::string& ProductSKUClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProductSKUClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProductSKUClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProductSKUClass_descriptor(), enum_t_value);
}
inline bool ProductSKUClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProductSKUClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProductSKUClass>(
    ProductSKUClass_descriptor(), name, value);
}
enum ProductSKUType : int {
  PRODUCT_NO_TYPE = 0,
  ProductSKUType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProductSKUType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProductSKUType_IsValid(int value);
constexpr ProductSKUType ProductSKUType_MIN = PRODUCT_NO_TYPE;
constexpr ProductSKUType ProductSKUType_MAX = PRODUCT_NO_TYPE;
constexpr int ProductSKUType_ARRAYSIZE = ProductSKUType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProductSKUType_descriptor();
template<typename T>
inline const std::string& ProductSKUType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProductSKUType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProductSKUType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProductSKUType_descriptor(), enum_t_value);
}
inline bool ProductSKUType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProductSKUType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProductSKUType>(
    ProductSKUType_descriptor(), name, value);
}
enum VisitType : int {
  NO_EVENT = 0,
  SOIL_TESTING = 1,
  CROP_TESTING = 2,
  FARMER_REGISTRATION = 3,
  FARMER_DEMO = 4,
  VisitType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VisitType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VisitType_IsValid(int value);
constexpr VisitType VisitType_MIN = NO_EVENT;
constexpr VisitType VisitType_MAX = FARMER_DEMO;
constexpr int VisitType_ARRAYSIZE = VisitType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VisitType_descriptor();
template<typename T>
inline const std::string& VisitType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VisitType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VisitType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VisitType_descriptor(), enum_t_value);
}
inline bool VisitType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VisitType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VisitType>(
    VisitType_descriptor(), name, value);
}
enum EventReason : int {
  NO_EVENT_REASON = 0,
  HERBICIDE = 1,
  PESTICIDE = 2,
  WEATHER = 3,
  EventReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EventReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EventReason_IsValid(int value);
constexpr EventReason EventReason_MIN = NO_EVENT_REASON;
constexpr EventReason EventReason_MAX = WEATHER;
constexpr int EventReason_ARRAYSIZE = EventReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventReason_descriptor();
template<typename T>
inline const std::string& EventReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventReason_descriptor(), enum_t_value);
}
inline bool EventReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventReason>(
    EventReason_descriptor(), name, value);
}
enum EventUpdateType : int {
  NO_UPDATE = 0,
  EVENT_UPDATE_MODIFY = 2,
  EVENT_UPDATE_CANCEL = 3,
  EVENT_UPDATE_OPERATOR_ACCEPT = 4,
  EVENT_UPDATE_OPERATOR_DENY = 5,
  EVENT_UPDATE_SCHEDULE_TIME = 1,
  EVENT_UPDATE_SCHEDULE_AREA = 6,
  EVENT_UPDATE_SCHEDULE_AREA_TIME = 12,
  EVENT_UPDATE_REQUEST_TIME = 18,
  EVENT_UPDATE_REQUEST_AREA = 19,
  EVENT_UPDATE_REQUEST_AREA_TIME = 20,
  EVENT_UPDATE_ACTOR_ASSIGNED = 7,
  EVENT_UPDATE_ACTOR_REMOVED = 8,
  EVENT_UPDATE_SERVICE_AREA = 9,
  EVENT_UPDATE_SERVICE_AREA_TIME = 10,
  EVENT_UPDATE_SERVICE_TIME = 11,
  EVENT_UPDATE_SERVICE_START = 13,
  EVENT_UPDATE_SERVICE_PAUSE = 14,
  EVENT_UPDATE_SERVICE_RESUME = 15,
  EVENT_UPDATE_SERVICE_DONE = 16,
  EVENT_UPDATE_SERVICE_COMPLETED = 17,
  EVENT_UPDATE_CAP_AVAILABLE = 21,
  EVENT_UPDATE_CAP_UNAVAILABLE = 22,
  EVENT_UPDATE_SAMPLE_COLLECTION_COMPLETED = 23,
  EVENT_UPDATE_DELIVERY_COMPLETED = 24,
  EVENT_UPDATE_FARM_SCAN_COMPLETED = 25,
  EVENT_UPDATE_PAYMENT_COLLECTED = 26,
  EVENT_UPDATE_SERVICE_STOPPED = 27,
  EVENT_UPDATE_IOT_DETAILS = 28,
  EVENT_UPDATE_EDIT_ACRES = 29,
  EVENT_UPDATE_SOIL_ATTRIBUTES = 30,
  EventUpdateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EventUpdateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EventUpdateType_IsValid(int value);
constexpr EventUpdateType EventUpdateType_MIN = NO_UPDATE;
constexpr EventUpdateType EventUpdateType_MAX = EVENT_UPDATE_SOIL_ATTRIBUTES;
constexpr int EventUpdateType_ARRAYSIZE = EventUpdateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventUpdateType_descriptor();
template<typename T>
inline const std::string& EventUpdateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventUpdateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventUpdateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventUpdateType_descriptor(), enum_t_value);
}
inline bool EventUpdateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventUpdateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventUpdateType>(
    EventUpdateType_descriptor(), name, value);
}
enum ActorType : int {
  NO_ACTOR = 0,
  FARMER = 1,
  OPERATOR = 2,
  FIELD_OFFICER = 3,
  BUSINESS_DEVELOPMENT_OFFICER = 4,
  SUPPORT_AGENT = 5,
  ADARSH_KRISHI_CENTER = 6,
  EXTENSION_OFFICER = 7,
  EXTENSION_MANAGER = 8,
  CLUSTER_HEAD = 9,
  MACHINE = 10,
  SYSTEM = 42,
  RETAILER = 14,
  TECHNICIAN = 15,
  COORDINATOR = 16,
  ASSISTANT_STATE_MANAGER = 17,
  TEST_ACTOR = 18,
  LAB_TECHNICIAN = 19,
  GROWER = 20,
  SELLER = 21,
  SERVICE_BOOKING_INSIGHTS = 101,
  SHAKTIMAN_ADMIN = 102,
  CLUSTER_INCHARGE = 103,
  TERRITORY_MANAGER = 104,
  ZONAL_MARKETING_MANAGER = 105,
  ZONAL_SALES_MANAGER = 106,
  ZONAL_SERVICE_MANAGER = 107,
  ASSISTANT_BUSINESS_DEVELOPMENT_OFFICER = 108,
  ASSISTANT_ADMIN = 109,
  RETAILER_OFFICER = 110,
  ADMIN_EMPLOYEE = 111,
  UNIMART_ADMIN = 112,
  SBU_HEAD = 113,
  PARTNER = 114,
  UNIMART_F3_FO = 115,
  UNIMART_INTERN = 116,
  SUSTAIN_MITRA = 117,
  KRISHI_MITRA = 118,
  ActorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActorType_IsValid(int value);
constexpr ActorType ActorType_MIN = NO_ACTOR;
constexpr ActorType ActorType_MAX = KRISHI_MITRA;
constexpr int ActorType_ARRAYSIZE = ActorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActorType_descriptor();
template<typename T>
inline const std::string& ActorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActorType_descriptor(), enum_t_value);
}
inline bool ActorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActorType>(
    ActorType_descriptor(), name, value);
}
enum BookingSource : int {
  NO_BOOKING_SOURCE = 0,
  FARMER_APP = 1,
  OPERATOR_APP = 2,
  AKC_PORTAL = 3,
  TEST_PROBE_SOURCE = 4,
  RETAIL_APP = 5,
  ADMIN_APP = 6,
  SYSTEM_AUTO_CREATION = 7,
  BookingSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BookingSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BookingSource_IsValid(int value);
constexpr BookingSource BookingSource_MIN = NO_BOOKING_SOURCE;
constexpr BookingSource BookingSource_MAX = SYSTEM_AUTO_CREATION;
constexpr int BookingSource_ARRAYSIZE = BookingSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BookingSource_descriptor();
template<typename T>
inline const std::string& BookingSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BookingSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BookingSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BookingSource_descriptor(), enum_t_value);
}
inline bool BookingSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BookingSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BookingSource>(
    BookingSource_descriptor(), name, value);
}
enum ClientType : int {
  NO_CLIENT_TYPE = 0,
  CLIENT_FARMER_APP = 1,
  CLIENT_OPERATOR_APP = 2,
  CLIENT_ADMIN_APP = 3,
  CLIENT_TECHNICIAN_APP = 4,
  CLIENT_AKC_PORTAL = 5,
  CLIENT_SYS_ALLOCATION = 6,
  CLIENT_CAPTAIN = 7,
  CLIENT_MDM = 8,
  CLIENT_RETAIL_APP = 9,
  CLIENT_PARTNER_APP = 10,
  CLIENT_TRADE_APP = 11,
  CLIENT_UNIMART_APP = 12,
  ClientType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ClientType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ClientType_IsValid(int value);
constexpr ClientType ClientType_MIN = NO_CLIENT_TYPE;
constexpr ClientType ClientType_MAX = CLIENT_UNIMART_APP;
constexpr int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientType_descriptor();
template<typename T>
inline const std::string& ClientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientType_descriptor(), enum_t_value);
}
inline bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientType>(
    ClientType_descriptor(), name, value);
}
enum BookingStatusReason : int {
  NO_BOOKING_STATUS_REASON = 0,
  SOME_SERVICES_COMPLETED = 5,
  ALL_SERVICES_COMPLETED = 1,
  SOME_SERVICES_CANCELLED = 2,
  ALL_SERVICES_CANCELLED = 3,
  SOME_SERVICES_REJECTED = 4,
  BookingStatusReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BookingStatusReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BookingStatusReason_IsValid(int value);
constexpr BookingStatusReason BookingStatusReason_MIN = NO_BOOKING_STATUS_REASON;
constexpr BookingStatusReason BookingStatusReason_MAX = SOME_SERVICES_COMPLETED;
constexpr int BookingStatusReason_ARRAYSIZE = BookingStatusReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BookingStatusReason_descriptor();
template<typename T>
inline const std::string& BookingStatusReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BookingStatusReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BookingStatusReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BookingStatusReason_descriptor(), enum_t_value);
}
inline bool BookingStatusReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BookingStatusReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BookingStatusReason>(
    BookingStatusReason_descriptor(), name, value);
}
enum BookingStatus : int {
  NO_BOOKING_STATUS = 0,
  BOOKING_CREATED = 1,
  BOOKING_PARTIALLY_COMPLETED = 2,
  BOOKING_CANCELLED = 3,
  BOOKING_COMPLETED = 4,
  BOOKING_EXPIRED = 5,
  BookingStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BookingStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BookingStatus_IsValid(int value);
constexpr BookingStatus BookingStatus_MIN = NO_BOOKING_STATUS;
constexpr BookingStatus BookingStatus_MAX = BOOKING_EXPIRED;
constexpr int BookingStatus_ARRAYSIZE = BookingStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BookingStatus_descriptor();
template<typename T>
inline const std::string& BookingStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BookingStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BookingStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BookingStatus_descriptor(), enum_t_value);
}
inline bool BookingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BookingStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BookingStatus>(
    BookingStatus_descriptor(), name, value);
}
enum WorkflowStatus : int {
  NO_STATUS = 0,
  CREATED = 10,
  ACCEPTED = 15,
  CONFIRMED = 20,
  ASSIGNED = 30,
  SCHEDULED = 40,
  DISPATCHED = 50,
  STARTED = 60,
  COMPLETED = 80,
  SERVICE_PAUSED = 200,
  SERVICE_BREAK = 220,
  SAMPLE_COLLECTION_COMPLETED = 251,
  DELIVERY_COMPLETED = 252,
  FARM_SCAN_COMPLETED = 253,
  PAYMENT_COLLECTED = 254,
  SUSPENDED = 300,
  CANCELLED = 320,
  REJECTED = 420,
  RESUMED = 421,
  STOPPED = 422,
  WorkflowStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkflowStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkflowStatus_IsValid(int value);
constexpr WorkflowStatus WorkflowStatus_MIN = NO_STATUS;
constexpr WorkflowStatus WorkflowStatus_MAX = STOPPED;
constexpr int WorkflowStatus_ARRAYSIZE = WorkflowStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkflowStatus_descriptor();
template<typename T>
inline const std::string& WorkflowStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkflowStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkflowStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkflowStatus_descriptor(), enum_t_value);
}
inline bool WorkflowStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkflowStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkflowStatus>(
    WorkflowStatus_descriptor(), name, value);
}
enum WorkflowStatusReason : int {
  NO_WORKFLOW_REASON = 0,
  REASON_SERVICE_TASK_DONE = 1,
  REASON_SERVICE_CANCELLED = 34,
  REASON_MACHINE_BREAKDOWN = 2,
  REASON_CUSTOMER_NOT_READY = 3,
  REASON_PRODUCT_NOT_MATCHED = 4,
  REASON_ACTOR_ALLOTMENT = 5,
  REASON_PRODUCT_SKU_ATTACHED = 6,
  REASON_OPERATOR_REMOVED = 7,
  REASON_MACHINE_REMOVED = 8,
  REASON_PRODUCT_SKU_ATTACHMENT_REMOVED = 9,
  REASON_ACTOR_REMOVED = 10,
  REASON_TASK_STARTED = 11,
  REASON_TASK_PAUSED = 12,
  REASON_TASK_RESUMED = 13,
  REASON_OPERATOR_FARMER_CONFIRMED = 14,
  REASON_ACTOR_ON_WAY = 15,
  REASON_LACK_OF_WATER = 16,
  REASON_BAD_WEATHER = 17,
  REASON_PESTICIDE_ON_CROP = 18,
  REASON_HERBICIDE_ON_CROP = 19,
  REASON_LAND_NOT_FOUND = 20,
  REASON_CROP_NOT_FOUND = 21,
  REASON_BOOKING_CREATED = 22,
  REASON_BOOKING_CANCELLED = 32,
  REASON_BOOKING_COMPLETED = 33,
  REASON_TASK_GROUP_REMOVED = 23,
  REASON_TASK_GROUP_ADDED = 24,
  REASON_TASK_GROUP_UPDATED = 25,
  REASON_CAPACITY_AVAILABLE = 26,
  REASON_CAPACITY_UNAVAILABLE = 27,
  REASON_CAPACITY_EVICTED = 36,
  REASON_PLANNER_ALLOC_AVAILABLE = 28,
  REASON_PLANNER_ALLOC_UNAVAILABLE = 29,
  REASON_PLANNER_DAILY_ALLOTMENT = 30,
  REASON_MANUAL_ALLOTMENT = 31,
  REASON_UPDATE_FAILED = 37,
  REASON_UNALLOTTED_FAILED = 38,
  REASON_EVICTION_DUE_TO_HIGH_DEMAND = 50,
  REASON_EDIT_LIMIT_CROSSED = 39,
  REASON_BAD_REQUEST = 40,
  REASON_BAD_INPUT_REQUEST_TIME = 41,
  REASON_BAD_INPUT_REQUEST_AREA = 42,
  REASON_BAD_INPUT_SERVICE_AREA = 43,
  REASON_MACHINE_PREVENTIVE_MAINTENANCE = 44,
  REASON_MACHINE_PREVENTIVE_MAINTENANCE_RESCHEDULED = 45,
  REASON_NO_SUPPLY_PRESENT = 71,
  REASON_MISSING_REQUIRED_ACTORS = 72,
  REASON_SUPPLY_IN_BREAKDOWN = 73,
  REASON_SUPPLY_CALENDAR_FULL = 74,
  REASON_SUPPLY_GROUP_INVALID_SKILL_SET_IDS = 75,
  REASON_MACHINE_CAME_LATE = 81,
  REASON_OPERATOR_NOT_REACHABLE = 82,
  REASON_PRODUCT_NOT_AVAILABLE = 83,
  REASON_REQUEST_EXPIRED = 84,
  REASON_PUSA_NO_DESIRED_RESULT = 85,
  REASON_PUSA_GROWING_OTHER_CROP = 86,
  REASON_PUSA_USING_OTHER_EQUIPMENT = 87,
  REASON_FAR_LOCATION = 91,
  REASON_TASK_STOPPED = 101,
  WorkflowStatusReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WorkflowStatusReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WorkflowStatusReason_IsValid(int value);
constexpr WorkflowStatusReason WorkflowStatusReason_MIN = NO_WORKFLOW_REASON;
constexpr WorkflowStatusReason WorkflowStatusReason_MAX = REASON_TASK_STOPPED;
constexpr int WorkflowStatusReason_ARRAYSIZE = WorkflowStatusReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorkflowStatusReason_descriptor();
template<typename T>
inline const std::string& WorkflowStatusReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorkflowStatusReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorkflowStatusReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorkflowStatusReason_descriptor(), enum_t_value);
}
inline bool WorkflowStatusReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WorkflowStatusReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorkflowStatusReason>(
    WorkflowStatusReason_descriptor(), name, value);
}
enum ActorAllotmentStatus : int {
  NO_ALLOT_STATUS = 0,
  ACTOR_ASSIGNED = 1,
  ACTOR_REMOVED = 10,
  ACTOR_REMOVED_BEFORE_ON_WAY = 11,
  ACTOR_ON_WAY = 2,
  ACTOR_REMOVED_BEFORE_STARTED = 12,
  ACTOR_STARTED = 4,
  ACTOR_REMOVED_AFTER_START = 15,
  ACTOR_PAUSED = 5,
  ACTOR_DONE = 6,
  ActorAllotmentStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActorAllotmentStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActorAllotmentStatus_IsValid(int value);
constexpr ActorAllotmentStatus ActorAllotmentStatus_MIN = NO_ALLOT_STATUS;
constexpr ActorAllotmentStatus ActorAllotmentStatus_MAX = ACTOR_REMOVED_AFTER_START;
constexpr int ActorAllotmentStatus_ARRAYSIZE = ActorAllotmentStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActorAllotmentStatus_descriptor();
template<typename T>
inline const std::string& ActorAllotmentStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActorAllotmentStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActorAllotmentStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActorAllotmentStatus_descriptor(), enum_t_value);
}
inline bool ActorAllotmentStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActorAllotmentStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActorAllotmentStatus>(
    ActorAllotmentStatus_descriptor(), name, value);
}
enum ActorAllotmentStatusReason : int {
  NO_ALLOT_STATUS_REASON = 0,
  OPERATOR_ASSIGNED = 1,
  AKC_ASSIGNED = 2,
  ACTOR_REASSIGNED = 3,
  SERVICE_TASK_COMPLETED = 4,
  SERVICE_ACTOR_PART_DONE = 5,
  OPERATOR_ON_WAY = 6,
  OPERATOR_STARTED = 7,
  OPERATOR_PAUSED_FOR_WATER = 8,
  OPERATOR_CANCELLED = 9,
  FARMER_CANCELLED = 10,
  OPERATOR_OR_FARMER_CANCELLED = 11,
  SUPPLY_UNAVAILABLE = 12,
  ActorAllotmentStatusReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActorAllotmentStatusReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActorAllotmentStatusReason_IsValid(int value);
constexpr ActorAllotmentStatusReason ActorAllotmentStatusReason_MIN = NO_ALLOT_STATUS_REASON;
constexpr ActorAllotmentStatusReason ActorAllotmentStatusReason_MAX = SUPPLY_UNAVAILABLE;
constexpr int ActorAllotmentStatusReason_ARRAYSIZE = ActorAllotmentStatusReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActorAllotmentStatusReason_descriptor();
template<typename T>
inline const std::string& ActorAllotmentStatusReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActorAllotmentStatusReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActorAllotmentStatusReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActorAllotmentStatusReason_descriptor(), enum_t_value);
}
inline bool ActorAllotmentStatusReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActorAllotmentStatusReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActorAllotmentStatusReason>(
    ActorAllotmentStatusReason_descriptor(), name, value);
}
enum ProductSKUPurchaseChannel : int {
  NO_PURCHASE_CHANNEL = 0,
  PURCHASE_CHANNEL_UNKNOWN = 1,
  PURCHASE_FROM_DEALER = 2,
  PURCHASE_FROM_OPERATOR = 3,
  PURCHASE_FROM_THIRD_PARTY = 4,
  ProductSKUPurchaseChannel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProductSKUPurchaseChannel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProductSKUPurchaseChannel_IsValid(int value);
constexpr ProductSKUPurchaseChannel ProductSKUPurchaseChannel_MIN = NO_PURCHASE_CHANNEL;
constexpr ProductSKUPurchaseChannel ProductSKUPurchaseChannel_MAX = PURCHASE_FROM_THIRD_PARTY;
constexpr int ProductSKUPurchaseChannel_ARRAYSIZE = ProductSKUPurchaseChannel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProductSKUPurchaseChannel_descriptor();
template<typename T>
inline const std::string& ProductSKUPurchaseChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProductSKUPurchaseChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProductSKUPurchaseChannel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProductSKUPurchaseChannel_descriptor(), enum_t_value);
}
inline bool ProductSKUPurchaseChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProductSKUPurchaseChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProductSKUPurchaseChannel>(
    ProductSKUPurchaseChannel_descriptor(), name, value);
}
enum ProductSKUDomain : int {
  NO_SKU_DOMAIN = 0,
  DOMAIN_UPL = 1,
  ProductSKUDomain_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProductSKUDomain_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProductSKUDomain_IsValid(int value);
constexpr ProductSKUDomain ProductSKUDomain_MIN = NO_SKU_DOMAIN;
constexpr ProductSKUDomain ProductSKUDomain_MAX = DOMAIN_UPL;
constexpr int ProductSKUDomain_ARRAYSIZE = ProductSKUDomain_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProductSKUDomain_descriptor();
template<typename T>
inline const std::string& ProductSKUDomain_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProductSKUDomain>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProductSKUDomain_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProductSKUDomain_descriptor(), enum_t_value);
}
inline bool ProductSKUDomain_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProductSKUDomain* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProductSKUDomain>(
    ProductSKUDomain_descriptor(), name, value);
}
enum ProductAttachmentStatus : int {
  NO_ATTACHMENT_STATUS = 0,
  VERIFIED_SUCCESS = 1,
  FAKE_PRODUCT = 2,
  ProductAttachmentStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProductAttachmentStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProductAttachmentStatus_IsValid(int value);
constexpr ProductAttachmentStatus ProductAttachmentStatus_MIN = NO_ATTACHMENT_STATUS;
constexpr ProductAttachmentStatus ProductAttachmentStatus_MAX = FAKE_PRODUCT;
constexpr int ProductAttachmentStatus_ARRAYSIZE = ProductAttachmentStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProductAttachmentStatus_descriptor();
template<typename T>
inline const std::string& ProductAttachmentStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProductAttachmentStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProductAttachmentStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProductAttachmentStatus_descriptor(), enum_t_value);
}
inline bool ProductAttachmentStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProductAttachmentStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProductAttachmentStatus>(
    ProductAttachmentStatus_descriptor(), name, value);
}
enum Currency : int {
  NO_CURRENCY_KNOWN = 0,
  INR = 1,
  USD = 2,
  CAD = 3,
  AUD = 4,
  REWARD_POINTS = 5,
  Currency_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Currency_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Currency_IsValid(int value);
constexpr Currency Currency_MIN = NO_CURRENCY_KNOWN;
constexpr Currency Currency_MAX = REWARD_POINTS;
constexpr int Currency_ARRAYSIZE = Currency_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Currency_descriptor();
template<typename T>
inline const std::string& Currency_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Currency>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Currency_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Currency_descriptor(), enum_t_value);
}
inline bool Currency_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Currency* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Currency>(
    Currency_descriptor(), name, value);
}
enum TaskStatus : int {
  NO_TASK_STATUS = 0,
  TASK_CREATED = 1,
  TASK_STARTED = 2,
  TASK_COMPLETED = 3,
  PARENT_CANCELLED = 10,
  TaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskStatus_IsValid(int value);
constexpr TaskStatus TaskStatus_MIN = NO_TASK_STATUS;
constexpr TaskStatus TaskStatus_MAX = PARENT_CANCELLED;
constexpr int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskStatus_descriptor();
template<typename T>
inline const std::string& TaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskStatus_descriptor(), enum_t_value);
}
inline bool TaskStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskStatus>(
    TaskStatus_descriptor(), name, value);
}
enum RequestStatus : int {
  NO_REQUEST_STATUS = 0,
  SUCCESS = 200,
  BAD_INPUT = 400,
  NOT_FOUND = 404,
  REQUEST_NOT_FULFILLED = 412,
  REQUEST_NOT_AUTHORIZED = 401,
  INTERNAL_ERROR = 500,
  PARTIAL_CONTENT = 206,
  INVALID_VERSION = 550,
  RequestStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RequestStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RequestStatus_IsValid(int value);
constexpr RequestStatus RequestStatus_MIN = NO_REQUEST_STATUS;
constexpr RequestStatus RequestStatus_MAX = INVALID_VERSION;
constexpr int RequestStatus_ARRAYSIZE = RequestStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestStatus_descriptor();
template<typename T>
inline const std::string& RequestStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestStatus_descriptor(), enum_t_value);
}
inline bool RequestStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestStatus>(
    RequestStatus_descriptor(), name, value);
}
enum RequestStatusReason : int {
  NO_REQUEST_STATUS_REASON = 0,
  DB_NOT_FOUND_ERROR = 4000,
  DB_DUPLICATE_KEY_ERROR = 4001,
  DB_INTERNAL_ERROR = 5000,
  REQUEST_PREPARE_FAILED = 6000,
  RESPONSE_READ_FAILED = 7000,
  JSON_PARSE_FAILED = 7001,
  WORKFLOW_CLOSED = 8000,
  DB_CREATE_BOOKING_ERROR = 50000,
  DB_CREATE_SERVICE_ERROR = 50001,
  DB_CREATE_BOOKING_SERVICE_ERROR = 50002,
  DB_UPDATE_BOOKING_ERROR = 50100,
  DB_UPDATE_SERVICE_ERROR = 50101,
  DB_UPDATE_BOOKING_SERVICE_ERROR = 50102,
  DB_GET_BOOKING_ERROR = 50200,
  DB_GET_SERVICE_ERROR = 50201,
  DB_GET_BOOKING_SERVICE_ERROR = 50202,
  REWARDS_BACKEND_CALL_FAILED = 50304,
  COMMUNICATION_CALL_FAILED = 50401,
  SAM_CALL_FAILED = 50501,
  BN_CALL_FAILED = 50601,
  AFS_CALL_FAILED = 50701,
  PE_CALL_FAILED = 50801,
  LMS_CALL_FAILED = 50901,
  FARM_SERVICE_CALL_FAILED = 51001,
  CROP_MODEL_CALL_FAILED = 51101,
  SUPPLY_WORKFLOWS_CALL_FAILED = 51201,
  BOOKING_WORKFLOWS_CALL_FAILED = 51202,
  PT_GET_SCORE_FAILED = 60000,
  PT_SCORE_CALCULATION_FAILED = 60001,
  CAPACITY_UNAVAILABLE = 70000,
  NO_SUPPLY_AVAILABLE = 70001,
  REVERSE_TRANSACTION_EVENT_NOT_FOUND = 80000,
  REQUEST_CHANGE_VALIDITY_FAILED = 100000,
  REQUEST_TIME_VALIDITY_FAILED = 1000001,
  REQUEST_AREA_VALIDITY_FAILED = 1000002,
  REQUEST_AREA_IS_LOW = 1000003,
  REQUEST_TIME_IS_PAST = 1000004,
  REQUEST_TIME_IS_TOO_FUTURE = 1000005,
  REQUEST_CHANGE_FAILED = 1000006,
  REQUEST_UPDATE_FAILED = 1000007,
  REQUEST_COMPLETE_FAILED = 100008,
  REQUEST_CANCEL_FAILED = 100009,
  REQUEST_SERVICE_AREA_EMPTY = 1000010,
  REQUEST_SERVICE_AREA_ID_EMPTY = 1000011,
  REQUEST_SERVICE_AREA_NS_EMPTY = 1000012,
  REQUEST_DUPLICATE_TRANSACTION = 1100001,
  REQUEST_INSUFFICIENT_FUNDS = 1100002,
  CASHBACK_REQUEST_MONTHLY_LIMIT_EXCEEDED = 1100003,
  FARM_DATA_NOT_FOUND = 1200001,
  RequestStatusReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RequestStatusReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RequestStatusReason_IsValid(int value);
constexpr RequestStatusReason RequestStatusReason_MIN = NO_REQUEST_STATUS_REASON;
constexpr RequestStatusReason RequestStatusReason_MAX = FARM_DATA_NOT_FOUND;
constexpr int RequestStatusReason_ARRAYSIZE = RequestStatusReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestStatusReason_descriptor();
template<typename T>
inline const std::string& RequestStatusReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestStatusReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestStatusReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestStatusReason_descriptor(), enum_t_value);
}
inline bool RequestStatusReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestStatusReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestStatusReason>(
    RequestStatusReason_descriptor(), name, value);
}
enum EventReferenceType : int {
  NO_EVENT_REFERENCE_TYPE = 0,
  PACKAGE = 1,
  SALES = 2,
  EventReferenceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EventReferenceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EventReferenceType_IsValid(int value);
constexpr EventReferenceType EventReferenceType_MIN = NO_EVENT_REFERENCE_TYPE;
constexpr EventReferenceType EventReferenceType_MAX = SALES;
constexpr int EventReferenceType_ARRAYSIZE = EventReferenceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventReferenceType_descriptor();
template<typename T>
inline const std::string& EventReferenceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventReferenceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventReferenceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventReferenceType_descriptor(), enum_t_value);
}
inline bool EventReferenceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventReferenceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventReferenceType>(
    EventReferenceType_descriptor(), name, value);
}
enum DebugLevel : int {
  NO_DEBUG_LEVEL = 0,
  PRODUCTION = 1,
  GAMMA = 2,
  BETA = 3,
  ALPHA = 4,
  STAGE = 10,
  DEV = 20,
  VERBOSE = 30,
  DebugLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DebugLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DebugLevel_IsValid(int value);
constexpr DebugLevel DebugLevel_MIN = NO_DEBUG_LEVEL;
constexpr DebugLevel DebugLevel_MAX = VERBOSE;
constexpr int DebugLevel_ARRAYSIZE = DebugLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugLevel_descriptor();
template<typename T>
inline const std::string& DebugLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugLevel_descriptor(), enum_t_value);
}
inline bool DebugLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DebugLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugLevel>(
    DebugLevel_descriptor(), name, value);
}
enum TriggerType : int {
  NO_TRIGGER = 0,
  TRIGGER_ALLOTMENT = 1,
  TRIGGER_RE_ALLOTMENT = 2,
  TRIGGER_CANCEL_ALLOTMENT = 3,
  TRIGGER_APP_NOTIFICATION = 10,
  TRIGGER_APP_SMS_NOTIFICATION = 11,
  TRIGGER_SMS = 12,
  TRIGGER_CALL = 13,
  TRIGGER_BOOKING = 20,
  TRIGGER_QR_CODE_SCAN = 30,
  TriggerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TriggerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TriggerType_IsValid(int value);
constexpr TriggerType TriggerType_MIN = NO_TRIGGER;
constexpr TriggerType TriggerType_MAX = TRIGGER_QR_CODE_SCAN;
constexpr int TriggerType_ARRAYSIZE = TriggerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TriggerType_descriptor();
template<typename T>
inline const std::string& TriggerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TriggerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TriggerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TriggerType_descriptor(), enum_t_value);
}
inline bool TriggerType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TriggerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TriggerType>(
    TriggerType_descriptor(), name, value);
}
enum TriggerSubType : int {
  NO_TRIGGER_SUB_TYPE = 0,
  TriggerSubType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TriggerSubType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TriggerSubType_IsValid(int value);
constexpr TriggerSubType TriggerSubType_MIN = NO_TRIGGER_SUB_TYPE;
constexpr TriggerSubType TriggerSubType_MAX = NO_TRIGGER_SUB_TYPE;
constexpr int TriggerSubType_ARRAYSIZE = TriggerSubType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TriggerSubType_descriptor();
template<typename T>
inline const std::string& TriggerSubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TriggerSubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TriggerSubType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TriggerSubType_descriptor(), enum_t_value);
}
inline bool TriggerSubType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TriggerSubType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TriggerSubType>(
    TriggerSubType_descriptor(), name, value);
}
enum TaskType : int {
  NO_TASK = 0,
  ALLOTMENT_TASK = 1,
  RE_ALLOTMENT_TASK = 2,
  CANCEL_ALLOTMENT_TASK = 3,
  APP_NOTIFICATION_TASK = 10,
  APP_SMS_NOTIFICATION_TASK = 11,
  SMS_TASK = 12,
  CALL_TASK = 13,
  EVENT_CREATION = 20,
  PRODUCT_CONFIRMATION = 30,
  TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskType_IsValid(int value);
constexpr TaskType TaskType_MIN = NO_TASK;
constexpr TaskType TaskType_MAX = PRODUCT_CONFIRMATION;
constexpr int TaskType_ARRAYSIZE = TaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskType_descriptor();
template<typename T>
inline const std::string& TaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskType_descriptor(), enum_t_value);
}
inline bool TaskType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskType>(
    TaskType_descriptor(), name, value);
}
enum TaskSubType : int {
  NO_TASK_SUB_TYPE = 0,
  TaskSubType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskSubType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskSubType_IsValid(int value);
constexpr TaskSubType TaskSubType_MIN = NO_TASK_SUB_TYPE;
constexpr TaskSubType TaskSubType_MAX = NO_TASK_SUB_TYPE;
constexpr int TaskSubType_ARRAYSIZE = TaskSubType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskSubType_descriptor();
template<typename T>
inline const std::string& TaskSubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskSubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskSubType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskSubType_descriptor(), enum_t_value);
}
inline bool TaskSubType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskSubType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskSubType>(
    TaskSubType_descriptor(), name, value);
}
enum ActorInServiceStatus : int {
  NO_ACTOR_STATUS = 0,
  ENABLED_ACTOR = 1,
  DISABLED_ACTOR = 2,
  ActorInServiceStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActorInServiceStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActorInServiceStatus_IsValid(int value);
constexpr ActorInServiceStatus ActorInServiceStatus_MIN = NO_ACTOR_STATUS;
constexpr ActorInServiceStatus ActorInServiceStatus_MAX = DISABLED_ACTOR;
constexpr int ActorInServiceStatus_ARRAYSIZE = ActorInServiceStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActorInServiceStatus_descriptor();
template<typename T>
inline const std::string& ActorInServiceStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActorInServiceStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActorInServiceStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActorInServiceStatus_descriptor(), enum_t_value);
}
inline bool ActorInServiceStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActorInServiceStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActorInServiceStatus>(
    ActorInServiceStatus_descriptor(), name, value);
}
enum SKUProductInServiceStatus : int {
  NO_SKU_PRODUCT_STATUS = 0,
  ENABLED_SKU_PRODUCT = 1,
  DISABLED_SKU_PRODUCT = 2,
  SKUProductInServiceStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SKUProductInServiceStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SKUProductInServiceStatus_IsValid(int value);
constexpr SKUProductInServiceStatus SKUProductInServiceStatus_MIN = NO_SKU_PRODUCT_STATUS;
constexpr SKUProductInServiceStatus SKUProductInServiceStatus_MAX = DISABLED_SKU_PRODUCT;
constexpr int SKUProductInServiceStatus_ARRAYSIZE = SKUProductInServiceStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SKUProductInServiceStatus_descriptor();
template<typename T>
inline const std::string& SKUProductInServiceStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SKUProductInServiceStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SKUProductInServiceStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SKUProductInServiceStatus_descriptor(), enum_t_value);
}
inline bool SKUProductInServiceStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SKUProductInServiceStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SKUProductInServiceStatus>(
    SKUProductInServiceStatus_descriptor(), name, value);
}
enum TaskOperation : int {
  NO_OP = 0,
  TASK_ADD = 1,
  TASK_DELETE = 2,
  TASK_RESCHEDULE = 3,
  TASK_MODIFY = 4,
  TaskOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaskOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaskOperation_IsValid(int value);
constexpr TaskOperation TaskOperation_MIN = NO_OP;
constexpr TaskOperation TaskOperation_MAX = TASK_MODIFY;
constexpr int TaskOperation_ARRAYSIZE = TaskOperation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskOperation_descriptor();
template<typename T>
inline const std::string& TaskOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskOperation_descriptor(), enum_t_value);
}
inline bool TaskOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskOperation>(
    TaskOperation_descriptor(), name, value);
}
enum TimeSlotType : int {
  NO_TIME_SLOT = 0,
  REQUEST_TIME_SLOT = 1,
  SCHEDULE_TIME_SLOT = 2,
  SERVICE_TIME_SLOT = 3,
  CREATED_TIME_SLOT = 4,
  SERVER_UPDATED_TIME_SLOT = 5,
  TimeSlotType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TimeSlotType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TimeSlotType_IsValid(int value);
constexpr TimeSlotType TimeSlotType_MIN = NO_TIME_SLOT;
constexpr TimeSlotType TimeSlotType_MAX = SERVER_UPDATED_TIME_SLOT;
constexpr int TimeSlotType_ARRAYSIZE = TimeSlotType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeSlotType_descriptor();
template<typename T>
inline const std::string& TimeSlotType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeSlotType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeSlotType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimeSlotType_descriptor(), enum_t_value);
}
inline bool TimeSlotType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeSlotType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeSlotType>(
    TimeSlotType_descriptor(), name, value);
}
enum ServiceAreaNamespace : int {
  NO_SERVICE_AREA_NAMESPACE = 0,
  COMMON_SPRAYER_NAMESPACE = 1,
  VILLAGE_NAMESPACE = 2,
  COMMON_STS_NAMESPACE = 3,
  ORCHID_SPRAYING_NAMESPACE = 4,
  PUSA_SPRAYING_NAMESPACE = 5,
  GROUNDNUT_HARVESTING_NAMESPACE = 6,
  SEED_TREATMENT_NAMESPACE = 7,
  POTATO_PLANTER_NAMESPACE = 8,
  CULTIVATOR_NAMESPACE = 9,
  DISC_HARROW_NAMESPACE = 10,
  ROTAVATOR_NAMESPACE = 11,
  MB_PLOUGH_NAMESPACE = 12,
  TRACK_TYPE_COMBINE_HARVESTER_NAMESPACE = 13,
  COMBINE_HARVESTER_NAMESPACE = 14,
  SEED_DRILL_NAMESPACE = 15,
  MANUAL_LEVELER_NAMESPACE = 16,
  HAPPY_SEEDER_NAMESPACE = 17,
  SUPER_SEEDER_NAMESPACE = 18,
  ZERO_SEED_DRILL_NAMESPACE = 19,
  TROLLEY_NAMESPACE = 20,
  TRACTOR_CAGE_WHEEL_NAMESPACE = 21,
  PADDY_RIDGER_NAMESPACE = 22,
  MULCHER_NAMESPACE = 23,
  BAILER_NAMESPACE = 24,
  POWER_TILLER_NAMESPACE = 25,
  POWER_WEEDER_NAMESPACE = 26,
  POWER_REAPER_NAMESPACE = 27,
  SHREDDER_NAMESPACE = 28,
  POTATO_DIGGER_NAMESPACE = 29,
  POTATO_HARVESTER_NAMESPACE = 30,
  PADDY_THRESHER_NAMESPACE = 31,
  THRESHER_NAMESPACE = 32,
  STRAW_REAPER_NAMESPACE = 33,
  GROUNDNUT_DIGGER_NAMESPACE = 34,
  MANGO_SPRAY_NAMESPACE = 35,
  LASER_LAND_LEVELLER_NAMESPACE = 36,
  POMEGRANATE_SPRAYER_NAMESPACE = 37,
  MAIZE_PLANTING_NAMESPACE = 38,
  SUGARCANE_PLANTER_NAMESPACE = 39,
  SOIL_SAMPLING_NAMESPACE = 40,
  DRONE_SPRAYING_NAMESPACE = 41,
  SOIL_TESTING_ML_NAMESPACE = 42,
  SOYBEAN_HARVESTING_NAMESPACE = 43,
  ServiceAreaNamespace_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ServiceAreaNamespace_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ServiceAreaNamespace_IsValid(int value);
constexpr ServiceAreaNamespace ServiceAreaNamespace_MIN = NO_SERVICE_AREA_NAMESPACE;
constexpr ServiceAreaNamespace ServiceAreaNamespace_MAX = SOYBEAN_HARVESTING_NAMESPACE;
constexpr int ServiceAreaNamespace_ARRAYSIZE = ServiceAreaNamespace_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceAreaNamespace_descriptor();
template<typename T>
inline const std::string& ServiceAreaNamespace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceAreaNamespace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceAreaNamespace_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceAreaNamespace_descriptor(), enum_t_value);
}
inline bool ServiceAreaNamespace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceAreaNamespace* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceAreaNamespace>(
    ServiceAreaNamespace_descriptor(), name, value);
}
enum LocationType : int {
  NO_LOCATION_TYPE = 0,
  FARM_LOCATION = 1,
  FARMER_LOCATION = 2,
  UNIMART_LOCATION = 3,
  FARMER_VILLAGE_LOCATION = 4,
  LocationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LocationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LocationType_IsValid(int value);
constexpr LocationType LocationType_MIN = NO_LOCATION_TYPE;
constexpr LocationType LocationType_MAX = FARMER_VILLAGE_LOCATION;
constexpr int LocationType_ARRAYSIZE = LocationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocationType_descriptor();
template<typename T>
inline const std::string& LocationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LocationType_descriptor(), enum_t_value);
}
inline bool LocationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LocationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LocationType>(
    LocationType_descriptor(), name, value);
}
enum BookingAction : int {
  NO_BOOKING_ACTION = 0,
  BOOKING_ACTION_CANCEL = 1,
  BOOKING_ACTION_UPDATE = 2,
  BookingAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BookingAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BookingAction_IsValid(int value);
constexpr BookingAction BookingAction_MIN = NO_BOOKING_ACTION;
constexpr BookingAction BookingAction_MAX = BOOKING_ACTION_UPDATE;
constexpr int BookingAction_ARRAYSIZE = BookingAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BookingAction_descriptor();
template<typename T>
inline const std::string& BookingAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BookingAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BookingAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BookingAction_descriptor(), enum_t_value);
}
inline bool BookingAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BookingAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BookingAction>(
    BookingAction_descriptor(), name, value);
}
enum ServiceAction : int {
  NO_SERVICE_ACTION = 0,
  SERVICE_ACTION_CREATE = 1,
  SERVICE_ACTION_CANCEL = 3,
  SERVICE_ACTION_DETAILS = 4,
  SERVICE_ACTION_RESCHEDULE = 5,
  SERVICE_ACTION_FEEDBACK = 6,
  SERVICE_ACTION_ADD_ALLOTMENT = 7,
  SERVICE_ACTION_REMOVE_ALLOTMENT = 8,
  SERVICE_ACTION_CHANGE_ALLOTMENT = 9,
  SERVICE_ACTION_ADD_PRODUCT = 14,
  SERVICE_ACTION_REMOVE_PRODUCT = 15,
  SERVICE_ACTION_CHANGE_PRODUCT = 16,
  SERVICE_ACTION_UPDATE_REQ_SLOT = 17,
  SERVICE_ACTION_UPDATE_SCH_SLOT = 19,
  SERVICE_ACTION_UPDATE_SER_SLOT = 18,
  SERVICE_ACTION_UPDATE_REQ_AREA = 20,
  SERVICE_ACTION_UPDATE_SCH_AREA = 21,
  SERVICE_ACTION_UPDATE_SER_AREA = 22,
  SERVICE_ACTION_ACCEPT = 31,
  SERVICE_ACTION_ADD_ALLOTTED_ACTOR = 32,
  SERVICE_ACTION_CHANGE_ALLOTTED_ACTOR = 33,
  SERVICE_ACTION_CHANGE_MULTIPLE_ALLOTTED_ACTOR = 34,
  SERVICE_ACTION_EARLY_UNALLOTMENT = 36,
  SERVICE_ACTION_MAKE_ALLOTMENT = 37,
  SERVICE_ACTION_REJECT = 38,
  SERVICE_ACTION_REMOVE_ALLOTTED_ACTOR = 39,
  SERVICE_ACTION_SERVICE_AREA_TIME_UPDATE = 40,
  SERVICE_ACTION_UPDATE_ALLOTTED_ACTOR = 41,
  SERVICE_ACTION_UNALLOTTED = 42,
  SERVICE_ACTION_SAMPLE_COLLECTION_COMPLETED = 43,
  SERVICE_ACTION_DELIVERY_COMPLETED = 44,
  SERVICE_ACTION_FARM_SCAN_COMPLETED = 45,
  SERVICE_ACTION_PAYMENT_COLLECTED = 46,
  SERVICE_ACTION_START = 47,
  SERVICE_ACTION_PAUSE = 48,
  SERVICE_ACTION_SUSPEND = 49,
  SERVICE_ACTION_COMPLETE = 50,
  SERVICE_ACTION_EVICTION = 51,
  SERVICE_ACTION_RESUME = 52,
  SERVICE_ACTION_STOP = 53,
  SERVICE_ACTION_NO_ALLOTTED_ACTOR_UPDATES_AFTER_ALLOTMENT = 101,
  SERVICE_ACTION_NO_ALLOTTED_ACTOR_UPDATES_AFTER_ACCEPT = 102,
  SERVICE_ACTION_EDIT_ACRES = 126,
  ServiceAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ServiceAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ServiceAction_IsValid(int value);
constexpr ServiceAction ServiceAction_MIN = NO_SERVICE_ACTION;
constexpr ServiceAction ServiceAction_MAX = SERVICE_ACTION_EDIT_ACRES;
constexpr int ServiceAction_ARRAYSIZE = ServiceAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceAction_descriptor();
template<typename T>
inline const std::string& ServiceAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceAction_descriptor(), enum_t_value);
}
inline bool ServiceAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceAction>(
    ServiceAction_descriptor(), name, value);
}
enum CommunicationChannel : int {
  NO_CHANNEL = 0,
  SMS = 1,
  EMAIL = 2,
  APP_NOTIFICATION = 3,
  WHATSAPP = 4,
  CommunicationChannel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CommunicationChannel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CommunicationChannel_IsValid(int value);
constexpr CommunicationChannel CommunicationChannel_MIN = NO_CHANNEL;
constexpr CommunicationChannel CommunicationChannel_MAX = WHATSAPP;
constexpr int CommunicationChannel_ARRAYSIZE = CommunicationChannel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommunicationChannel_descriptor();
template<typename T>
inline const std::string& CommunicationChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommunicationChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommunicationChannel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CommunicationChannel_descriptor(), enum_t_value);
}
inline bool CommunicationChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommunicationChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CommunicationChannel>(
    CommunicationChannel_descriptor(), name, value);
}
enum CommunicationStatus : int {
  NO_COMM_STATUS = 0,
  COMM_ACCEPTED = 1,
  COMM_PENDING = 2,
  COMM_DELIVERED = 3,
  COMM_FAILED = 4,
  CommunicationStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CommunicationStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CommunicationStatus_IsValid(int value);
constexpr CommunicationStatus CommunicationStatus_MIN = NO_COMM_STATUS;
constexpr CommunicationStatus CommunicationStatus_MAX = COMM_FAILED;
constexpr int CommunicationStatus_ARRAYSIZE = CommunicationStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommunicationStatus_descriptor();
template<typename T>
inline const std::string& CommunicationStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommunicationStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommunicationStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CommunicationStatus_descriptor(), enum_t_value);
}
inline bool CommunicationStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommunicationStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CommunicationStatus>(
    CommunicationStatus_descriptor(), name, value);
}
enum CommunicationFailureCause : int {
  NO_CAUSE = 0,
  COMM_OPERATOR_FAILURE = 1,
  COMM_NUMBER_NOT_REACHABLE = 2,
  COMM_NUMBER_NOT_EXIST = 3,
  COMM_NUMBER_BLOCKED = 4,
  COMM_SYSTEM_FAILURE = 5,
  CommunicationFailureCause_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CommunicationFailureCause_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CommunicationFailureCause_IsValid(int value);
constexpr CommunicationFailureCause CommunicationFailureCause_MIN = NO_CAUSE;
constexpr CommunicationFailureCause CommunicationFailureCause_MAX = COMM_SYSTEM_FAILURE;
constexpr int CommunicationFailureCause_ARRAYSIZE = CommunicationFailureCause_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommunicationFailureCause_descriptor();
template<typename T>
inline const std::string& CommunicationFailureCause_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommunicationFailureCause>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommunicationFailureCause_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CommunicationFailureCause_descriptor(), enum_t_value);
}
inline bool CommunicationFailureCause_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommunicationFailureCause* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CommunicationFailureCause>(
    CommunicationFailureCause_descriptor(), name, value);
}
enum ResponseStatus : int {
  NO_RESPONSE_STATUS = 0,
  SUCCESSFUL = 1,
  ERROR = 2,
  NOT__FOUND = 3,
  ZERO_RESULTS = 4,
  DUPLICATE = 5,
  LIMIT__EXCEEDED = 6,
  INVALID_REQUEST = 7,
  TEMPORARILY_SUSPENDED = 8,
  OVER_USAGE_LIMIT = 9,
  REQUEST_DENIED = 10,
  UNKNOWN_ERROR = 11,
  DB_FAILURE = 12,
  ResponseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResponseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResponseStatus_IsValid(int value);
constexpr ResponseStatus ResponseStatus_MIN = NO_RESPONSE_STATUS;
constexpr ResponseStatus ResponseStatus_MAX = DB_FAILURE;
constexpr int ResponseStatus_ARRAYSIZE = ResponseStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseStatus_descriptor();
template<typename T>
inline const std::string& ResponseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseStatus_descriptor(), enum_t_value);
}
inline bool ResponseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseStatus>(
    ResponseStatus_descriptor(), name, value);
}
enum ResponseStatusCode : int {
  NO_RESPONSE_STATUS_CODE = 0,
  OK = 200,
  NO_CONTENT = 204,
  BAD_REQUEST = 400,
  UNAUTHORIZED = 401,
  ENTITY_NOT_FOUND = 404,
  GONE = 410,
  INTERNAL_SERVER_ERROR = 500,
  SQL_ERROR = 512,
  DUPLICATE_ENTRY = 409,
  LIMIT_EXCEEDED = 429,
  PROFILE_EXIST_OTP_SENT = 1000,
  PROFILE_CREATED_OTP_SENT = 1001,
  USER_VALIDATION = 1002,
  FARMER_PROFILE_CREATED = 1003,
  MULTIPLE_UNIQUE_ACCOUNT_BY_SAME_DEVICE_ERROR = 1004,
  USER_NOT_FOUND = 2001,
  INVALID_OTP = 2002,
  OTP_EXPIRED = 2003,
  USER_ALREADY_REGISTERED = 2004,
  INACTIVE_USER_REGISTRATION = 2005,
  ResponseStatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResponseStatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResponseStatusCode_IsValid(int value);
constexpr ResponseStatusCode ResponseStatusCode_MIN = NO_RESPONSE_STATUS_CODE;
constexpr ResponseStatusCode ResponseStatusCode_MAX = INACTIVE_USER_REGISTRATION;
constexpr int ResponseStatusCode_ARRAYSIZE = ResponseStatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseStatusCode_descriptor();
template<typename T>
inline const std::string& ResponseStatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseStatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseStatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseStatusCode_descriptor(), enum_t_value);
}
inline bool ResponseStatusCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseStatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseStatusCode>(
    ResponseStatusCode_descriptor(), name, value);
}
enum Status : int {
  NO_KNOWN_STATUS = 0,
  ACTIVE = 1,
  INACTIVE = 2,
  Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Status_IsValid(int value);
constexpr Status Status_MIN = NO_KNOWN_STATUS;
constexpr Status Status_MAX = INACTIVE;
constexpr int Status_ARRAYSIZE = Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_descriptor();
template<typename T>
inline const std::string& Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_descriptor(), enum_t_value);
}
inline bool Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum FarmCropStatus : int {
  NO_FARM_CROP_STATUS = 0,
  SOWED = 1,
  HARVESTED = 2,
  DELETED = 3,
  FarmCropStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FarmCropStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FarmCropStatus_IsValid(int value);
constexpr FarmCropStatus FarmCropStatus_MIN = NO_FARM_CROP_STATUS;
constexpr FarmCropStatus FarmCropStatus_MAX = DELETED;
constexpr int FarmCropStatus_ARRAYSIZE = FarmCropStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FarmCropStatus_descriptor();
template<typename T>
inline const std::string& FarmCropStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FarmCropStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FarmCropStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FarmCropStatus_descriptor(), enum_t_value);
}
inline bool FarmCropStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FarmCropStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FarmCropStatus>(
    FarmCropStatus_descriptor(), name, value);
}
enum MediaProvider : int {
  NO_MEDIA_PROVIDER = 0,
  AWS_S3 = 1,
  MediaProvider_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MediaProvider_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MediaProvider_IsValid(int value);
constexpr MediaProvider MediaProvider_MIN = NO_MEDIA_PROVIDER;
constexpr MediaProvider MediaProvider_MAX = AWS_S3;
constexpr int MediaProvider_ARRAYSIZE = MediaProvider_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MediaProvider_descriptor();
template<typename T>
inline const std::string& MediaProvider_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MediaProvider>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MediaProvider_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MediaProvider_descriptor(), enum_t_value);
}
inline bool MediaProvider_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MediaProvider* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MediaProvider>(
    MediaProvider_descriptor(), name, value);
}
enum DurationUnit : int {
  NO_DURATION_UNIT = 0,
  DAYS = 1,
  YEARS = 2,
  DurationUnit_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DurationUnit_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DurationUnit_IsValid(int value);
constexpr DurationUnit DurationUnit_MIN = NO_DURATION_UNIT;
constexpr DurationUnit DurationUnit_MAX = YEARS;
constexpr int DurationUnit_ARRAYSIZE = DurationUnit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DurationUnit_descriptor();
template<typename T>
inline const std::string& DurationUnit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DurationUnit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DurationUnit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DurationUnit_descriptor(), enum_t_value);
}
inline bool DurationUnit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DurationUnit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DurationUnit>(
    DurationUnit_descriptor(), name, value);
}
enum DurationType : int {
  NO_DURATION_TYPE = 0,
  SHORT = 1,
  MEDIUM = 2,
  LONG = 3,
  DurationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DurationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DurationType_IsValid(int value);
constexpr DurationType DurationType_MIN = NO_DURATION_TYPE;
constexpr DurationType DurationType_MAX = LONG;
constexpr int DurationType_ARRAYSIZE = DurationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DurationType_descriptor();
template<typename T>
inline const std::string& DurationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DurationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DurationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DurationType_descriptor(), enum_t_value);
}
inline bool DurationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DurationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DurationType>(
    DurationType_descriptor(), name, value);
}
enum ScaleType : int {
  NO_SCALE_TYPE = 0,
  BBCH = 1,
  ScaleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ScaleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ScaleType_IsValid(int value);
constexpr ScaleType ScaleType_MIN = NO_SCALE_TYPE;
constexpr ScaleType ScaleType_MAX = BBCH;
constexpr int ScaleType_ARRAYSIZE = ScaleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScaleType_descriptor();
template<typename T>
inline const std::string& ScaleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScaleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScaleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScaleType_descriptor(), enum_t_value);
}
inline bool ScaleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScaleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScaleType>(
    ScaleType_descriptor(), name, value);
}
enum LanguageCode : int {
  NO_LANGUAGE_CODE = 0,
  EN_US = 1,
  HI_IN = 2,
  GU = 3,
  PA = 4,
  KA = 5,
  TA = 6,
  TE = 7,
  BN = 8,
  MR = 9,
  ML = 10,
  KN = 11,
  OD = 12,
  PU = 13,
  LanguageCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LanguageCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LanguageCode_IsValid(int value);
constexpr LanguageCode LanguageCode_MIN = NO_LANGUAGE_CODE;
constexpr LanguageCode LanguageCode_MAX = PU;
constexpr int LanguageCode_ARRAYSIZE = LanguageCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LanguageCode_descriptor();
template<typename T>
inline const std::string& LanguageCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LanguageCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LanguageCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LanguageCode_descriptor(), enum_t_value);
}
inline bool LanguageCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LanguageCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LanguageCode>(
    LanguageCode_descriptor(), name, value);
}
enum RewardType : int {
  NO_REWARD_TYPE = 0,
  REWARD_POINT = 1,
  HEALTH_INSURANCE = 2,
  PRIORITY_SERVICE = 3,
  FIELD_ADVISORY = 4,
  SPRAY_SERVICE_DISCOUNT = 5,
  SERVICE_CASHBACK = 6,
  BOOKING_DISCOUNT = 7,
  KAVACH_DISCOUNT = 8,
  PRICE_GUARANTEE_DISCOUNT = 9,
  DISCOUNT_COUPON = 10,
  RewardType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RewardType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RewardType_IsValid(int value);
constexpr RewardType RewardType_MIN = NO_REWARD_TYPE;
constexpr RewardType RewardType_MAX = DISCOUNT_COUPON;
constexpr int RewardType_ARRAYSIZE = RewardType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RewardType_descriptor();
template<typename T>
inline const std::string& RewardType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RewardType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RewardType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RewardType_descriptor(), enum_t_value);
}
inline bool RewardType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RewardType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RewardType>(
    RewardType_descriptor(), name, value);
}
enum UserActionType : int {
  NO_USER_ACTION_TYPE = 0,
  PRODUCT_SCAN_SUCCESS = 1,
  PRODUCT_SCAN_FAILURE = 2,
  REQUESTED_SERVICE = 3,
  CANCELLED_SERVICE = 4,
  COMPLETED_SERVICE = 5,
  PROUCT_SCAN_ZERO_POINTS = 6,
  SIGN_UP = 7,
  SURVEY_COMPLETED = 8,
  PACKAGE_SIGNUP = 9,
  PARTIAL_REDEMPTION_SERVICE = 10,
  FIRST_REWARD_POINT = 11,
  CASHBACK_REQUEST = 12,
  USER_REGISTRATION = 13,
  ADD_FARM = 14,
  ADD_BANK_DETAILS = 15,
  PRODUCT_GROUP_SCAN = 16,
  BOOK_SERVICE = 17,
  PRODUCT_SCAN_NOT_FOUND = 18,
  PRODUCT_SCAN_MONTHLY_LIMIT = 19,
  PRODUCT_SCAN_WEEKLY_LIMIT = 20,
  PRODUCT_ALREADY_SCANNED = 21,
  PROMOTIONAL_ACTIVITY = 22,
  SEED_TREATMENT_MACHINE_SCAN_FAILURE = 23,
  SEED_TREATMENT_MACHINE_SCAN_SUCCESS = 24,
  SEED_TREATMENT_MACHINE_SCAN_ZERO_POINTS = 25,
  SEED_TREATMENT_MACHINE_SCAN_NOT_FOUND = 26,
  PRODUCT_SCAN = 27,
  DOCTOR_CALL_REQUEST = 28,
  SEGMENT_CHANGE = 29,
  ORDER_DELIVERED = 30,
  WEATHER_CASH_GUARANTEE = 31,
  OFFER_CASHBACK = 32,
  SPRAY_BOOKING = 33,
  DAILY_QUIZ_WINNER = 34,
  F2F_POINT_EXPIRY = 35,
  UserActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserActionType_IsValid(int value);
constexpr UserActionType UserActionType_MIN = NO_USER_ACTION_TYPE;
constexpr UserActionType UserActionType_MAX = F2F_POINT_EXPIRY;
constexpr int UserActionType_ARRAYSIZE = UserActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserActionType_descriptor();
template<typename T>
inline const std::string& UserActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserActionType_descriptor(), enum_t_value);
}
inline bool UserActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserActionType>(
    UserActionType_descriptor(), name, value);
}
enum AppID : int {
  NO_APP_ID = 0,
  NF_SMS = 1,
  UNIMART = 2,
  AFS_TECHNICIAN = 3,
  AFS_ADMIN = 4,
  AFS_OPERATOR = 5,
  NF_FARMER = 6,
  NF_FARMER_IOS = 7,
  NF_RETAILER = 8,
  AFS_COORDINATOR = 9,
  NF_PARTNER = 10,
  AppID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AppID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AppID_IsValid(int value);
constexpr AppID AppID_MIN = NO_APP_ID;
constexpr AppID AppID_MAX = NF_PARTNER;
constexpr int AppID_ARRAYSIZE = AppID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppID_descriptor();
template<typename T>
inline const std::string& AppID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppID_descriptor(), enum_t_value);
}
inline bool AppID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppID>(
    AppID_descriptor(), name, value);
}
enum AppType : int {
  NO_APP_TYPE = 0,
  ANDROID = 1,
  IOS = 2,
  AppType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AppType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AppType_IsValid(int value);
constexpr AppType AppType_MIN = NO_APP_TYPE;
constexpr AppType AppType_MAX = IOS;
constexpr int AppType_ARRAYSIZE = AppType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppType_descriptor();
template<typename T>
inline const std::string& AppType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppType_descriptor(), enum_t_value);
}
inline bool AppType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppType>(
    AppType_descriptor(), name, value);
}
enum HandoverType : int {
  NO_HANDOVER_TYPE = 0,
  INITIATED = 1,
  COMPLETE = 2,
  HandoverType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HandoverType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HandoverType_IsValid(int value);
constexpr HandoverType HandoverType_MIN = NO_HANDOVER_TYPE;
constexpr HandoverType HandoverType_MAX = COMPLETE;
constexpr int HandoverType_ARRAYSIZE = HandoverType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HandoverType_descriptor();
template<typename T>
inline const std::string& HandoverType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HandoverType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HandoverType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HandoverType_descriptor(), enum_t_value);
}
inline bool HandoverType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HandoverType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HandoverType>(
    HandoverType_descriptor(), name, value);
}
enum HandoverStatus : int {
  NO_HANDOVER_STATUS = 0,
  SENT = 1,
  VERIFIED = 2,
  HandoverStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HandoverStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HandoverStatus_IsValid(int value);
constexpr HandoverStatus HandoverStatus_MIN = NO_HANDOVER_STATUS;
constexpr HandoverStatus HandoverStatus_MAX = VERIFIED;
constexpr int HandoverStatus_ARRAYSIZE = HandoverStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HandoverStatus_descriptor();
template<typename T>
inline const std::string& HandoverStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HandoverStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HandoverStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HandoverStatus_descriptor(), enum_t_value);
}
inline bool HandoverStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HandoverStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HandoverStatus>(
    HandoverStatus_descriptor(), name, value);
}
enum MachineEventAction : int {
  NO_MACHINE_EVENT_ACTION = 0,
  MACHINE_EVENT_ACTION_CREATE = 1,
  MACHINE_EVENT_ACTION_UPDATE = 2,
  MachineEventAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MachineEventAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MachineEventAction_IsValid(int value);
constexpr MachineEventAction MachineEventAction_MIN = NO_MACHINE_EVENT_ACTION;
constexpr MachineEventAction MachineEventAction_MAX = MACHINE_EVENT_ACTION_UPDATE;
constexpr int MachineEventAction_ARRAYSIZE = MachineEventAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MachineEventAction_descriptor();
template<typename T>
inline const std::string& MachineEventAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MachineEventAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MachineEventAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MachineEventAction_descriptor(), enum_t_value);
}
inline bool MachineEventAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MachineEventAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MachineEventAction>(
    MachineEventAction_descriptor(), name, value);
}
enum ScheduleType : int {
  NO_SCHEDULE_TYPE = 0,
  SCHEDULE = 1,
  RESCHCEDULE = 2,
  ScheduleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ScheduleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ScheduleType_IsValid(int value);
constexpr ScheduleType ScheduleType_MIN = NO_SCHEDULE_TYPE;
constexpr ScheduleType ScheduleType_MAX = RESCHCEDULE;
constexpr int ScheduleType_ARRAYSIZE = ScheduleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScheduleType_descriptor();
template<typename T>
inline const std::string& ScheduleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScheduleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScheduleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScheduleType_descriptor(), enum_t_value);
}
inline bool ScheduleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScheduleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScheduleType>(
    ScheduleType_descriptor(), name, value);
}
enum UserStatus : int {
  UNREGISTERED = 0,
  REGISTERED = 1,
  BLOCKED = 2,
  EMAIL_VERIFICATION_PENDING = 3,
  UserStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserStatus_IsValid(int value);
constexpr UserStatus UserStatus_MIN = UNREGISTERED;
constexpr UserStatus UserStatus_MAX = EMAIL_VERIFICATION_PENDING;
constexpr int UserStatus_ARRAYSIZE = UserStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserStatus_descriptor();
template<typename T>
inline const std::string& UserStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserStatus_descriptor(), enum_t_value);
}
inline bool UserStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserStatus>(
    UserStatus_descriptor(), name, value);
}
enum Gender : int {
  MALE = 0,
  FEMALE = 1,
  OTHER = 2,
  Gender_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Gender_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Gender_IsValid(int value);
constexpr Gender Gender_MIN = MALE;
constexpr Gender Gender_MAX = OTHER;
constexpr int Gender_ARRAYSIZE = Gender_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Gender_descriptor();
template<typename T>
inline const std::string& Gender_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Gender>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Gender_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Gender_descriptor(), enum_t_value);
}
inline bool Gender_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Gender* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Gender>(
    Gender_descriptor(), name, value);
}
enum AddressType : int {
  HOME = 0,
  STORE = 1,
  AddressType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AddressType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AddressType_IsValid(int value);
constexpr AddressType AddressType_MIN = HOME;
constexpr AddressType AddressType_MAX = STORE;
constexpr int AddressType_ARRAYSIZE = AddressType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddressType_descriptor();
template<typename T>
inline const std::string& AddressType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddressType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddressType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddressType_descriptor(), enum_t_value);
}
inline bool AddressType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddressType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddressType>(
    AddressType_descriptor(), name, value);
}
enum GeographyType : int {
  ZONE = 0,
  REGION = 1,
  DISTRICT = 2,
  TEHSIL = 3,
  VILLAGE = 4,
  GeographyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeographyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeographyType_IsValid(int value);
constexpr GeographyType GeographyType_MIN = ZONE;
constexpr GeographyType GeographyType_MAX = VILLAGE;
constexpr int GeographyType_ARRAYSIZE = GeographyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeographyType_descriptor();
template<typename T>
inline const std::string& GeographyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeographyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeographyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeographyType_descriptor(), enum_t_value);
}
inline bool GeographyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeographyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeographyType>(
    GeographyType_descriptor(), name, value);
}
enum DocumentType : int {
  PAN_CARD = 0,
  AADHAR_CARD = 1,
  PROFILE_PIC = 2,
  DRIVING_LICENSE = 3,
  CANCEL_CHEQUE = 4,
  POSP_CERTIFICATE = 5,
  DocumentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DocumentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DocumentType_IsValid(int value);
constexpr DocumentType DocumentType_MIN = PAN_CARD;
constexpr DocumentType DocumentType_MAX = POSP_CERTIFICATE;
constexpr int DocumentType_ARRAYSIZE = DocumentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DocumentType_descriptor();
template<typename T>
inline const std::string& DocumentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DocumentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DocumentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DocumentType_descriptor(), enum_t_value);
}
inline bool DocumentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DocumentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DocumentType>(
    DocumentType_descriptor(), name, value);
}
enum BookingEligibilityStatus : int {
  UNKNOWN_BOOKING_ELIGIBILITY_STATUS = 0,
  ENABLED = 1,
  DISABLED = 2,
  BookingEligibilityStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BookingEligibilityStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BookingEligibilityStatus_IsValid(int value);
constexpr BookingEligibilityStatus BookingEligibilityStatus_MIN = UNKNOWN_BOOKING_ELIGIBILITY_STATUS;
constexpr BookingEligibilityStatus BookingEligibilityStatus_MAX = DISABLED;
constexpr int BookingEligibilityStatus_ARRAYSIZE = BookingEligibilityStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BookingEligibilityStatus_descriptor();
template<typename T>
inline const std::string& BookingEligibilityStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BookingEligibilityStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BookingEligibilityStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BookingEligibilityStatus_descriptor(), enum_t_value);
}
inline bool BookingEligibilityStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BookingEligibilityStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BookingEligibilityStatus>(
    BookingEligibilityStatus_descriptor(), name, value);
}
enum BookingScheduleType : int {
  NO_BOOKING_SCHEDULE_TYPE = 0,
  HOURLY = 1,
  DAILY = 2,
  WEEKLY = 3,
  MONTHLY = 4,
  QUARTERLY = 5,
  ANNUALLY = 6,
  BookingScheduleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BookingScheduleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BookingScheduleType_IsValid(int value);
constexpr BookingScheduleType BookingScheduleType_MIN = NO_BOOKING_SCHEDULE_TYPE;
constexpr BookingScheduleType BookingScheduleType_MAX = ANNUALLY;
constexpr int BookingScheduleType_ARRAYSIZE = BookingScheduleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BookingScheduleType_descriptor();
template<typename T>
inline const std::string& BookingScheduleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BookingScheduleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BookingScheduleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BookingScheduleType_descriptor(), enum_t_value);
}
inline bool BookingScheduleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BookingScheduleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BookingScheduleType>(
    BookingScheduleType_descriptor(), name, value);
}
enum BookingNameSpace : int {
  NO_BOOKING_NAMESPACE = 0,
  NURTURE_FARM = 1,
  BookingNameSpace_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BookingNameSpace_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BookingNameSpace_IsValid(int value);
constexpr BookingNameSpace BookingNameSpace_MIN = NO_BOOKING_NAMESPACE;
constexpr BookingNameSpace BookingNameSpace_MAX = NURTURE_FARM;
constexpr int BookingNameSpace_ARRAYSIZE = BookingNameSpace_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BookingNameSpace_descriptor();
template<typename T>
inline const std::string& BookingNameSpace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BookingNameSpace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BookingNameSpace_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BookingNameSpace_descriptor(), enum_t_value);
}
inline bool BookingNameSpace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BookingNameSpace* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BookingNameSpace>(
    BookingNameSpace_descriptor(), name, value);
}
enum BookingClass : int {
  NO_BOOKING_CLASS = 0,
  BookingClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BookingClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BookingClass_IsValid(int value);
constexpr BookingClass BookingClass_MIN = NO_BOOKING_CLASS;
constexpr BookingClass BookingClass_MAX = NO_BOOKING_CLASS;
constexpr int BookingClass_ARRAYSIZE = BookingClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BookingClass_descriptor();
template<typename T>
inline const std::string& BookingClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BookingClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BookingClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BookingClass_descriptor(), enum_t_value);
}
inline bool BookingClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BookingClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BookingClass>(
    BookingClass_descriptor(), name, value);
}
enum Language : int {
  NO_LANGUAGE = 0,
  ENGLISH = 1,
  HINDI = 2,
  GUJARATI = 3,
  PUNJABI = 4,
  KANNADA = 5,
  TAMIL = 6,
  TELUGU = 7,
  MALAYALAM = 8,
  BENGALI = 9,
  MARATHI = 10,
  Language_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Language_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Language_IsValid(int value);
constexpr Language Language_MIN = NO_LANGUAGE;
constexpr Language Language_MAX = MARATHI;
constexpr int Language_ARRAYSIZE = Language_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Language_descriptor();
template<typename T>
inline const std::string& Language_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Language>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Language_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Language_descriptor(), enum_t_value);
}
inline bool Language_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Language* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Language>(
    Language_descriptor(), name, value);
}
enum Country : int {
  NO_COUNTRY = 0,
  INDIA = 1,
  AUSTRALIA = 2,
  Country_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Country_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Country_IsValid(int value);
constexpr Country Country_MIN = NO_COUNTRY;
constexpr Country Country_MAX = AUSTRALIA;
constexpr int Country_ARRAYSIZE = Country_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Country_descriptor();
template<typename T>
inline const std::string& Country_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Country>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Country_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Country_descriptor(), enum_t_value);
}
inline bool Country_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Country* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Country>(
    Country_descriptor(), name, value);
}
enum PushNotificationType : int {
  NO_PUSH_NOTIFICATION_TYPE = 0,
  NOTIFICATION = 1,
  DATA = 2,
  PushNotificationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PushNotificationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PushNotificationType_IsValid(int value);
constexpr PushNotificationType PushNotificationType_MIN = NO_PUSH_NOTIFICATION_TYPE;
constexpr PushNotificationType PushNotificationType_MAX = DATA;
constexpr int PushNotificationType_ARRAYSIZE = PushNotificationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PushNotificationType_descriptor();
template<typename T>
inline const std::string& PushNotificationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PushNotificationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PushNotificationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PushNotificationType_descriptor(), enum_t_value);
}
inline bool PushNotificationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PushNotificationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PushNotificationType>(
    PushNotificationType_descriptor(), name, value);
}
enum InfoType : int {
  NO_INFO_TYPE = 0,
  BASIC = 1,
  DETAILED = 2,
  InfoType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  InfoType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool InfoType_IsValid(int value);
constexpr InfoType InfoType_MIN = NO_INFO_TYPE;
constexpr InfoType InfoType_MAX = DETAILED;
constexpr int InfoType_ARRAYSIZE = InfoType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InfoType_descriptor();
template<typename T>
inline const std::string& InfoType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InfoType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InfoType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InfoType_descriptor(), enum_t_value);
}
inline bool InfoType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InfoType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InfoType>(
    InfoType_descriptor(), name, value);
}
enum DayDurationType : int {
  NO_DAY_DURATION_TYPE = 0,
  DAY = 1,
  NIGHT = 2,
  DayDurationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DayDurationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DayDurationType_IsValid(int value);
constexpr DayDurationType DayDurationType_MIN = NO_DAY_DURATION_TYPE;
constexpr DayDurationType DayDurationType_MAX = NIGHT;
constexpr int DayDurationType_ARRAYSIZE = DayDurationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DayDurationType_descriptor();
template<typename T>
inline const std::string& DayDurationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DayDurationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DayDurationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DayDurationType_descriptor(), enum_t_value);
}
inline bool DayDurationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DayDurationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DayDurationType>(
    DayDurationType_descriptor(), name, value);
}
enum DayOfWeek : int {
  NO_DAY_OF_WEEK = 0,
  MONDAY = 1,
  TUESDAY = 2,
  WEDNESDAY = 3,
  THURSDAY = 4,
  FRIDAY = 5,
  SATURDAY = 6,
  SUNDAY = 7,
  DayOfWeek_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DayOfWeek_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DayOfWeek_IsValid(int value);
constexpr DayOfWeek DayOfWeek_MIN = NO_DAY_OF_WEEK;
constexpr DayOfWeek DayOfWeek_MAX = SUNDAY;
constexpr int DayOfWeek_ARRAYSIZE = DayOfWeek_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DayOfWeek_descriptor();
template<typename T>
inline const std::string& DayOfWeek_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DayOfWeek>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DayOfWeek_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DayOfWeek_descriptor(), enum_t_value);
}
inline bool DayOfWeek_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DayOfWeek* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DayOfWeek>(
    DayOfWeek_descriptor(), name, value);
}
enum WeatherForecastType : int {
  NO_WEATHER_FORCECAST_TYPE = 0,
  DAILY_FORECAST = 1,
  HOURLY_FORECAST = 2,
  OBSERVATION = 3,
  HISTORY_FORECAST = 4,
  WeatherForecastType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WeatherForecastType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WeatherForecastType_IsValid(int value);
constexpr WeatherForecastType WeatherForecastType_MIN = NO_WEATHER_FORCECAST_TYPE;
constexpr WeatherForecastType WeatherForecastType_MAX = HISTORY_FORECAST;
constexpr int WeatherForecastType_ARRAYSIZE = WeatherForecastType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WeatherForecastType_descriptor();
template<typename T>
inline const std::string& WeatherForecastType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WeatherForecastType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WeatherForecastType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WeatherForecastType_descriptor(), enum_t_value);
}
inline bool WeatherForecastType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WeatherForecastType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WeatherForecastType>(
    WeatherForecastType_descriptor(), name, value);
}
enum CommunicationState : int {
  NO_COMMUNICATION_STATE = 0,
  VENDOR_UNDELIVERED = 1,
  VENDOR_DELIVERED = 2,
  CUSTOMER_UNDELIVERED = 3,
  CUSTOMER_DELIVERED = 4,
  PROCESSING_FAILED = 5,
  CUSTOMER_SENT = 6,
  CUSTOMER_READ = 7,
  CommunicationState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CommunicationState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CommunicationState_IsValid(int value);
constexpr CommunicationState CommunicationState_MIN = NO_COMMUNICATION_STATE;
constexpr CommunicationState CommunicationState_MAX = CUSTOMER_READ;
constexpr int CommunicationState_ARRAYSIZE = CommunicationState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommunicationState_descriptor();
template<typename T>
inline const std::string& CommunicationState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommunicationState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommunicationState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CommunicationState_descriptor(), enum_t_value);
}
inline bool CommunicationState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommunicationState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CommunicationState>(
    CommunicationState_descriptor(), name, value);
}
enum NutrientRating : int {
  NO_NUTRIENT_RATING = 0,
  SUFFICIENT = 1,
  DEFICIENT = 2,
  EXCESS = 3,
  NutrientRating_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NutrientRating_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NutrientRating_IsValid(int value);
constexpr NutrientRating NutrientRating_MIN = NO_NUTRIENT_RATING;
constexpr NutrientRating NutrientRating_MAX = EXCESS;
constexpr int NutrientRating_ARRAYSIZE = NutrientRating_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NutrientRating_descriptor();
template<typename T>
inline const std::string& NutrientRating_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NutrientRating>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NutrientRating_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NutrientRating_descriptor(), enum_t_value);
}
inline bool NutrientRating_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NutrientRating* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NutrientRating>(
    NutrientRating_descriptor(), name, value);
}
enum CropLandType : int {
  NO_CROPLAND_TYPE = 0,
  IRRIGATED = 1,
  NON_IRRIGATED = 2,
  CropLandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CropLandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CropLandType_IsValid(int value);
constexpr CropLandType CropLandType_MIN = NO_CROPLAND_TYPE;
constexpr CropLandType CropLandType_MAX = NON_IRRIGATED;
constexpr int CropLandType_ARRAYSIZE = CropLandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CropLandType_descriptor();
template<typename T>
inline const std::string& CropLandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CropLandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CropLandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CropLandType_descriptor(), enum_t_value);
}
inline bool CropLandType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CropLandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CropLandType>(
    CropLandType_descriptor(), name, value);
}
enum SynFertilizerReplacement : int {
  NO_SYN_FERTILIZER_REPLACEMENT = 0,
  BEEF_FEEDLOT = 1,
  CHICKEN_BROILER = 2,
  CHICKEN_LAYER = 3,
  DAIRY = 4,
  SHEEP = 5,
  SWINE = 6,
  OTHER_SYN_FERTILIZER = 7,
  SynFertilizerReplacement_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SynFertilizerReplacement_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SynFertilizerReplacement_IsValid(int value);
constexpr SynFertilizerReplacement SynFertilizerReplacement_MIN = NO_SYN_FERTILIZER_REPLACEMENT;
constexpr SynFertilizerReplacement SynFertilizerReplacement_MAX = OTHER_SYN_FERTILIZER;
constexpr int SynFertilizerReplacement_ARRAYSIZE = SynFertilizerReplacement_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SynFertilizerReplacement_descriptor();
template<typename T>
inline const std::string& SynFertilizerReplacement_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SynFertilizerReplacement>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SynFertilizerReplacement_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SynFertilizerReplacement_descriptor(), enum_t_value);
}
inline bool SynFertilizerReplacement_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SynFertilizerReplacement* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SynFertilizerReplacement>(
    SynFertilizerReplacement_descriptor(), name, value);
}
enum ActivityType : int {
  NO_ACTIVITY = 0,
  TILLAGE_REDUCTION = 1,
  SEASONAL_COVER_CROP = 2,
  FERTILIZER_REDUCTION_PERCENTAGE = 3,
  N_FERTILIZER_REDUCTION_PERCENTAGE = 4,
  SYN_FERTILIZER_REPLACEMENT = 5,
  SYN_N_FERTILIZER_REPLACED_WITH_COMPOST_CN = 6,
  SYN_N_FERTILIZER_REDUCTION_PERCENTAGE = 7,
  IMPROVE_FARM_FUEL_EFFICIENCY = 8,
  ActivityType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActivityType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActivityType_IsValid(int value);
constexpr ActivityType ActivityType_MIN = NO_ACTIVITY;
constexpr ActivityType ActivityType_MAX = IMPROVE_FARM_FUEL_EFFICIENCY;
constexpr int ActivityType_ARRAYSIZE = ActivityType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActivityType_descriptor();
template<typename T>
inline const std::string& ActivityType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActivityType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActivityType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActivityType_descriptor(), enum_t_value);
}
inline bool ActivityType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActivityType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActivityType>(
    ActivityType_descriptor(), name, value);
}
enum TemplateContentType : int {
  NO_TEMPLATE_CONTENT_TYPE = 0,
  STRING = 1,
  HTML = 2,
  TemplateContentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TemplateContentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TemplateContentType_IsValid(int value);
constexpr TemplateContentType TemplateContentType_MIN = NO_TEMPLATE_CONTENT_TYPE;
constexpr TemplateContentType TemplateContentType_MAX = HTML;
constexpr int TemplateContentType_ARRAYSIZE = TemplateContentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TemplateContentType_descriptor();
template<typename T>
inline const std::string& TemplateContentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TemplateContentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TemplateContentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TemplateContentType_descriptor(), enum_t_value);
}
inline bool TemplateContentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TemplateContentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TemplateContentType>(
    TemplateContentType_descriptor(), name, value);
}
enum ResponseOrderType : int {
  NO_RESPONSE_ORDER = 0,
  ASCENDING = 1,
  DESCENDING = 2,
  ResponseOrderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResponseOrderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResponseOrderType_IsValid(int value);
constexpr ResponseOrderType ResponseOrderType_MIN = NO_RESPONSE_ORDER;
constexpr ResponseOrderType ResponseOrderType_MAX = DESCENDING;
constexpr int ResponseOrderType_ARRAYSIZE = ResponseOrderType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseOrderType_descriptor();
template<typename T>
inline const std::string& ResponseOrderType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseOrderType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseOrderType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseOrderType_descriptor(), enum_t_value);
}
inline bool ResponseOrderType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseOrderType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseOrderType>(
    ResponseOrderType_descriptor(), name, value);
}
enum SecretType : int {
  NO_SECRET = 0,
  OTP = 1,
  PASSWORD = 2,
  SecretType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SecretType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SecretType_IsValid(int value);
constexpr SecretType SecretType_MIN = NO_SECRET;
constexpr SecretType SecretType_MAX = PASSWORD;
constexpr int SecretType_ARRAYSIZE = SecretType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecretType_descriptor();
template<typename T>
inline const std::string& SecretType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SecretType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SecretType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SecretType_descriptor(), enum_t_value);
}
inline bool SecretType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SecretType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecretType>(
    SecretType_descriptor(), name, value);
}
enum FeatureName : int {
  NO_FEATURE = 0,
  DOC_ON_CALL = 1,
  SPRAY_SERVICE_FEATURE = 2,
  WEATHER_UPDATES_FEATURE = 3,
  MANDI_UPDATES_FEATURE = 4,
  PRODUCT_SCAN_FEATURE = 5,
  VIDEO_FEED_CREATE_POST_FEATURE = 6,
  AUTOMATED_BOUNDARY_POLYGON = 7,
  FeatureName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FeatureName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FeatureName_IsValid(int value);
constexpr FeatureName FeatureName_MIN = NO_FEATURE;
constexpr FeatureName FeatureName_MAX = AUTOMATED_BOUNDARY_POLYGON;
constexpr int FeatureName_ARRAYSIZE = FeatureName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FeatureName_descriptor();
template<typename T>
inline const std::string& FeatureName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FeatureName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FeatureName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FeatureName_descriptor(), enum_t_value);
}
inline bool FeatureName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FeatureName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FeatureName>(
    FeatureName_descriptor(), name, value);
}
enum OfferKeyName : int {
  SEGMENT = 0,
  ORDER = 1,
  ORDERITEM = 2,
  USER_PROFILE = 3,
  CONTENT_VERIFICATION = 4,
  PRE_BOOKING_COUPONS = 5,
  POST_BOOKING_COUPONS = 6,
  PRODUCT_SCAN_ACTION = 7,
  F2F_REFERRAL = 8,
  F2F_REFERRAL_BONUS = 9,
  F2F_REFEREE_ONBOARDING = 10,
  DISCOUNT_ORDER = 11,
  OfferKeyName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OfferKeyName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OfferKeyName_IsValid(int value);
constexpr OfferKeyName OfferKeyName_MIN = SEGMENT;
constexpr OfferKeyName OfferKeyName_MAX = DISCOUNT_ORDER;
constexpr int OfferKeyName_ARRAYSIZE = OfferKeyName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OfferKeyName_descriptor();
template<typename T>
inline const std::string& OfferKeyName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OfferKeyName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OfferKeyName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OfferKeyName_descriptor(), enum_t_value);
}
inline bool OfferKeyName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OfferKeyName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OfferKeyName>(
    OfferKeyName_descriptor(), name, value);
}
enum OfferServiceKey : int {
  SEGMENT_SEGMENT_ID_ORIGINAL = 0,
  ORDER_ORDER_AMOUNT_SUM = 1,
  ORDERITEM_TOTAL_PACK_SIZE_SUM = 2,
  ORDER_IDENTIFIER_ID_DISTINCT_COUNT = 3,
  CONTENT_VERIFICATION_COMBINED_ID_LATEST = 4,
  ORDER_ORDER_AMOUNT_ORIGINAL = 5,
  ORDER_AMOUNT_WITHOUT_GST_SUM = 6,
  ORDER_AMOUNT_WITHOUT_GST_ORIGINAL = 7,
  PRE_BOOKING_COUPONS_BOOKING_COUNT = 8,
  POST_BOOKING_COUPONS_MATERIAL_GROUP_CODE_LIST = 9,
  POST_BOOKING_COUPONS_PRODUCT_REFERENCE_ID_LIST = 10,
  POST_BOOKING_COUPONS_PRODUCT_REFERENCE_TYPE_LIST = 11,
  ORDERITEM_AMOUNT_SUM = 12,
  ORDERITEM_AMOUNT_ORIGINAL = 13,
  ORDERITEM_AMOUNT_WITHOUT_GST_SUM = 14,
  ORDERITEM_AMOUNT_WITHOUT_GST_ORIGINAL = 15,
  DISCOUNT_ORDER_MASTER_ORDER_AMOUNT_ORIGINAL = 16,
  DISCOUNT_ORDER_MASTER_ORDER_AMOUNT_SUM = 17,
  DISCOUNT_ORDER_MASTER_ORDER_AMOUNT_WITHOUT_GST_SUM = 18,
  DISCOUNT_ORDER_MASTER_ORDER_AMOUNT_WITHOUT_GST_ORIGINAL = 19,
  OfferServiceKey_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OfferServiceKey_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OfferServiceKey_IsValid(int value);
constexpr OfferServiceKey OfferServiceKey_MIN = SEGMENT_SEGMENT_ID_ORIGINAL;
constexpr OfferServiceKey OfferServiceKey_MAX = DISCOUNT_ORDER_MASTER_ORDER_AMOUNT_WITHOUT_GST_ORIGINAL;
constexpr int OfferServiceKey_ARRAYSIZE = OfferServiceKey_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OfferServiceKey_descriptor();
template<typename T>
inline const std::string& OfferServiceKey_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OfferServiceKey>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OfferServiceKey_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OfferServiceKey_descriptor(), enum_t_value);
}
inline bool OfferServiceKey_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OfferServiceKey* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OfferServiceKey>(
    OfferServiceKey_descriptor(), name, value);
}
enum OfferMetaKey : int {
  ORDER_CREATED_AT_DATE = 0,
  ORDER_PLACED_AT_DATE = 1,
  ORDERITEM_PLACED_AT_DATE = 2,
  ORDERITEM_PRODUCT_GROUP_ORIGINAL = 3,
  ORDERITEM_IDENTIFIER_ID_LATEST = 4,
  CONTENT_VERIFICATION_EVENT_ID_ORIGINAL = 5,
  ORDER_PAYMENT_TYPE_ORIGINAL = 6,
  ORDER_IDENTIFIER_ID_LATEST = 7,
  ORDER_SELLER_NAME_ORIGINAL = 8,
  ORDERITEM_SELLER_NAME_ORIGINAL = 9,
  ORDERITEM_PRODUCT_NAME_ORIGINAL = 10,
  ORDERITEM_PAYMENT_TYPE_ORIGINAL = 11,
  DISCOUNT_ORDER_SELLER_NAME_ORIGINAL = 12,
  DISCOUNT_ORDER_PRODUCT_NAME_ORIGINAL = 13,
  OfferMetaKey_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OfferMetaKey_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OfferMetaKey_IsValid(int value);
constexpr OfferMetaKey OfferMetaKey_MIN = ORDER_CREATED_AT_DATE;
constexpr OfferMetaKey OfferMetaKey_MAX = DISCOUNT_ORDER_PRODUCT_NAME_ORIGINAL;
constexpr int OfferMetaKey_ARRAYSIZE = OfferMetaKey_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OfferMetaKey_descriptor();
template<typename T>
inline const std::string& OfferMetaKey_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OfferMetaKey>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OfferMetaKey_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OfferMetaKey_descriptor(), enum_t_value);
}
inline bool OfferMetaKey_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OfferMetaKey* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OfferMetaKey>(
    OfferMetaKey_descriptor(), name, value);
}
enum OfferCalculationType : int {
  NO_CALCULATION_TYPE = 0,
  DIRECT = 1,
  INDIRECT = 2,
  PERCENTAGE = 3,
  OfferCalculationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OfferCalculationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OfferCalculationType_IsValid(int value);
constexpr OfferCalculationType OfferCalculationType_MIN = NO_CALCULATION_TYPE;
constexpr OfferCalculationType OfferCalculationType_MAX = PERCENTAGE;
constexpr int OfferCalculationType_ARRAYSIZE = OfferCalculationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OfferCalculationType_descriptor();
template<typename T>
inline const std::string& OfferCalculationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OfferCalculationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OfferCalculationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OfferCalculationType_descriptor(), enum_t_value);
}
inline bool OfferCalculationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OfferCalculationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OfferCalculationType>(
    OfferCalculationType_descriptor(), name, value);
}
enum EngagementKeyName : int {
  SEGMENT_TYPE = 0,
  EngagementKeyName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EngagementKeyName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EngagementKeyName_IsValid(int value);
constexpr EngagementKeyName EngagementKeyName_MIN = SEGMENT_TYPE;
constexpr EngagementKeyName EngagementKeyName_MAX = SEGMENT_TYPE;
constexpr int EngagementKeyName_ARRAYSIZE = EngagementKeyName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EngagementKeyName_descriptor();
template<typename T>
inline const std::string& EngagementKeyName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EngagementKeyName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EngagementKeyName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EngagementKeyName_descriptor(), enum_t_value);
}
inline bool EngagementKeyName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EngagementKeyName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EngagementKeyName>(
    EngagementKeyName_descriptor(), name, value);
}
enum EngagementServiceUserSegmentKey : int {
  USER_PROFILE_USER_ID = 0,
  USER_PROFILE_CROP_ID = 1,
  USER_PROFILE_REGION_ID = 2,
  USER_PROFILE_FARM_ID = 3,
  USER_PROFILE_BANK_ID = 4,
  USER_PROFILE_NAMESPACE = 5,
  USER_PROFILE_STATE = 6,
  USER_PROFILE_DISTRICT = 7,
  USER_PROFILE_TEHSIL = 8,
  USER_PROFILE_VILLAGE = 9,
  USER_PROFILE_PINCODE = 10,
  USER_PROFILE_USER_TYPE = 11,
  USER_PROFILE_USER_GMV = 12,
  USER_PROFILE_DEPOS = 13,
  USER_PROFILE_RUPIFI_CREDIT_STATUS = 14,
  EngagementServiceUserSegmentKey_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EngagementServiceUserSegmentKey_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EngagementServiceUserSegmentKey_IsValid(int value);
constexpr EngagementServiceUserSegmentKey EngagementServiceUserSegmentKey_MIN = USER_PROFILE_USER_ID;
constexpr EngagementServiceUserSegmentKey EngagementServiceUserSegmentKey_MAX = USER_PROFILE_RUPIFI_CREDIT_STATUS;
constexpr int EngagementServiceUserSegmentKey_ARRAYSIZE = EngagementServiceUserSegmentKey_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EngagementServiceUserSegmentKey_descriptor();
template<typename T>
inline const std::string& EngagementServiceUserSegmentKey_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EngagementServiceUserSegmentKey>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EngagementServiceUserSegmentKey_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EngagementServiceUserSegmentKey_descriptor(), enum_t_value);
}
inline bool EngagementServiceUserSegmentKey_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EngagementServiceUserSegmentKey* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EngagementServiceUserSegmentKey>(
    EngagementServiceUserSegmentKey_descriptor(), name, value);
}
enum ContentMimeType : int {
  NO_CONTENT_MIME_TYPE = 0,
  VIDEO_MP4 = 1,
  MIME_TYPE_IMAGE = 2,
  MIME_TYPE_TEXT = 3,
  MIME_TYPE_GROUP = 4,
  ContentMimeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ContentMimeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ContentMimeType_IsValid(int value);
constexpr ContentMimeType ContentMimeType_MIN = NO_CONTENT_MIME_TYPE;
constexpr ContentMimeType ContentMimeType_MAX = MIME_TYPE_GROUP;
constexpr int ContentMimeType_ARRAYSIZE = ContentMimeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContentMimeType_descriptor();
template<typename T>
inline const std::string& ContentMimeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentMimeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentMimeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContentMimeType_descriptor(), enum_t_value);
}
inline bool ContentMimeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentMimeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContentMimeType>(
    ContentMimeType_descriptor(), name, value);
}
enum UserContentStatus : int {
  NO_USER_CONTENT_STATUS = 0,
  LIKED = 1,
  DISLIKED = 2,
  UserContentStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserContentStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserContentStatus_IsValid(int value);
constexpr UserContentStatus UserContentStatus_MIN = NO_USER_CONTENT_STATUS;
constexpr UserContentStatus UserContentStatus_MAX = DISLIKED;
constexpr int UserContentStatus_ARRAYSIZE = UserContentStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserContentStatus_descriptor();
template<typename T>
inline const std::string& UserContentStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserContentStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserContentStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserContentStatus_descriptor(), enum_t_value);
}
inline bool UserContentStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserContentStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserContentStatus>(
    UserContentStatus_descriptor(), name, value);
}
enum QuestionType : int {
  NO_QUESTION_TYPE = 0,
  TEXT = 1,
  NUMERIC = 2,
  TEXT_MULTI_CHOICE = 3,
  NUMERIC_MULTI_CHOICE = 4,
  FILL_IN_THE_BLANK = 5,
  FILE_UPLOAD = 6,
  QuestionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  QuestionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool QuestionType_IsValid(int value);
constexpr QuestionType QuestionType_MIN = NO_QUESTION_TYPE;
constexpr QuestionType QuestionType_MAX = FILE_UPLOAD;
constexpr int QuestionType_ARRAYSIZE = QuestionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestionType_descriptor();
template<typename T>
inline const std::string& QuestionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestionType_descriptor(), enum_t_value);
}
inline bool QuestionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestionType>(
    QuestionType_descriptor(), name, value);
}
enum ComparisonCheckType : int {
  NO_COMPARISON_CHECK_TYPE = 0,
  IN = 1,
  BW = 2,
  LESS = 3,
  GREATER = 4,
  LESS_EQUAL = 5,
  GREATER_EQUAL = 6,
  EQUAL = 7,
  NOT_EQUAL = 8,
  NOT_IN = 9,
  ComparisonCheckType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ComparisonCheckType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ComparisonCheckType_IsValid(int value);
constexpr ComparisonCheckType ComparisonCheckType_MIN = NO_COMPARISON_CHECK_TYPE;
constexpr ComparisonCheckType ComparisonCheckType_MAX = NOT_IN;
constexpr int ComparisonCheckType_ARRAYSIZE = ComparisonCheckType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ComparisonCheckType_descriptor();
template<typename T>
inline const std::string& ComparisonCheckType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ComparisonCheckType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ComparisonCheckType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ComparisonCheckType_descriptor(), enum_t_value);
}
inline bool ComparisonCheckType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ComparisonCheckType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ComparisonCheckType>(
    ComparisonCheckType_descriptor(), name, value);
}
enum Tenant : int {
  NO_TENANT = 0,
  HFX = 1,
  SEEDHOP = 2,
  Tenant_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Tenant_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Tenant_IsValid(int value);
constexpr Tenant Tenant_MIN = NO_TENANT;
constexpr Tenant Tenant_MAX = SEEDHOP;
constexpr int Tenant_ARRAYSIZE = Tenant_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Tenant_descriptor();
template<typename T>
inline const std::string& Tenant_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Tenant>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Tenant_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Tenant_descriptor(), enum_t_value);
}
inline bool Tenant_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Tenant* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Tenant>(
    Tenant_descriptor(), name, value);
}
enum MediaType : int {
  NO_MEDIA_TYPE = 0,
  IMAGE = 1,
  DOCUMENT = 2,
  VIDEO = 3,
  MediaType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MediaType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MediaType_IsValid(int value);
constexpr MediaType MediaType_MIN = NO_MEDIA_TYPE;
constexpr MediaType MediaType_MAX = VIDEO;
constexpr int MediaType_ARRAYSIZE = MediaType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MediaType_descriptor();
template<typename T>
inline const std::string& MediaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MediaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MediaType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MediaType_descriptor(), enum_t_value);
}
inline bool MediaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MediaType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MediaType>(
    MediaType_descriptor(), name, value);
}
enum MediaAccessType : int {
  NO_MEDIA_ACCESS_TYPE = 0,
  PUBLIC_URL = 1,
  DOCUMENT_ID = 2,
  MediaAccessType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MediaAccessType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MediaAccessType_IsValid(int value);
constexpr MediaAccessType MediaAccessType_MIN = NO_MEDIA_ACCESS_TYPE;
constexpr MediaAccessType MediaAccessType_MAX = DOCUMENT_ID;
constexpr int MediaAccessType_ARRAYSIZE = MediaAccessType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MediaAccessType_descriptor();
template<typename T>
inline const std::string& MediaAccessType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MediaAccessType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MediaAccessType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MediaAccessType_descriptor(), enum_t_value);
}
inline bool MediaAccessType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MediaAccessType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MediaAccessType>(
    MediaAccessType_descriptor(), name, value);
}
enum DPSource : int {
  NO_DP_SOURCE = 0,
  CLEVERTAP = 1,
  DPSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DPSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DPSource_IsValid(int value);
constexpr DPSource DPSource_MIN = NO_DP_SOURCE;
constexpr DPSource DPSource_MAX = CLEVERTAP;
constexpr int DPSource_ARRAYSIZE = DPSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DPSource_descriptor();
template<typename T>
inline const std::string& DPSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DPSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DPSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DPSource_descriptor(), enum_t_value);
}
inline bool DPSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DPSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DPSource>(
    DPSource_descriptor(), name, value);
}
enum EventSubType : int {
  NO_EVENT_SUBTYPE = 0,
  CONTENT_MANAGEMENT_SYSTEM = 1,
  EventSubType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EventSubType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EventSubType_IsValid(int value);
constexpr EventSubType EventSubType_MIN = NO_EVENT_SUBTYPE;
constexpr EventSubType EventSubType_MAX = CONTENT_MANAGEMENT_SYSTEM;
constexpr int EventSubType_ARRAYSIZE = EventSubType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventSubType_descriptor();
template<typename T>
inline const std::string& EventSubType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventSubType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventSubType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventSubType_descriptor(), enum_t_value);
}
inline bool EventSubType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventSubType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventSubType>(
    EventSubType_descriptor(), name, value);
}
enum CultivationPractice : int {
  NO_CULTIVATION_PRACTICE = 0,
  AWD = 1,
  DSR = 2,
  TRANSPLANTED = 3,
  CultivationPractice_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CultivationPractice_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CultivationPractice_IsValid(int value);
constexpr CultivationPractice CultivationPractice_MIN = NO_CULTIVATION_PRACTICE;
constexpr CultivationPractice CultivationPractice_MAX = TRANSPLANTED;
constexpr int CultivationPractice_ARRAYSIZE = CultivationPractice_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CultivationPractice_descriptor();
template<typename T>
inline const std::string& CultivationPractice_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CultivationPractice>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CultivationPractice_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CultivationPractice_descriptor(), enum_t_value);
}
inline bool CultivationPractice_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CultivationPractice* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CultivationPractice>(
    CultivationPractice_descriptor(), name, value);
}
enum PracticeChangeType : int {
  NO_PRACTICE = 0,
  PC_TILLAGE_REDUCTION = 1,
  PC_COVER_CROP_ADDITION = 2,
  PC_MANURE_ADDITION = 3,
  PC_FERTILIZER_REDUCTION = 4,
  PracticeChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PracticeChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PracticeChangeType_IsValid(int value);
constexpr PracticeChangeType PracticeChangeType_MIN = NO_PRACTICE;
constexpr PracticeChangeType PracticeChangeType_MAX = PC_FERTILIZER_REDUCTION;
constexpr int PracticeChangeType_ARRAYSIZE = PracticeChangeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PracticeChangeType_descriptor();
template<typename T>
inline const std::string& PracticeChangeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PracticeChangeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PracticeChangeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PracticeChangeType_descriptor(), enum_t_value);
}
inline bool PracticeChangeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PracticeChangeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PracticeChangeType>(
    PracticeChangeType_descriptor(), name, value);
}
enum ApprovalStatus : int {
  NO_APPROVAL_STATUS = 0,
  IN_PROGRESS = 1,
  APPROVED = 2,
  REJECT = 3,
  CONTENT_VERIFIED = 4,
  CARE_NEEDED = 5,
  ApprovalStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ApprovalStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ApprovalStatus_IsValid(int value);
constexpr ApprovalStatus ApprovalStatus_MIN = NO_APPROVAL_STATUS;
constexpr ApprovalStatus ApprovalStatus_MAX = CARE_NEEDED;
constexpr int ApprovalStatus_ARRAYSIZE = ApprovalStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ApprovalStatus_descriptor();
template<typename T>
inline const std::string& ApprovalStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ApprovalStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ApprovalStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ApprovalStatus_descriptor(), enum_t_value);
}
inline bool ApprovalStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApprovalStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ApprovalStatus>(
    ApprovalStatus_descriptor(), name, value);
}
enum ApprovalStatusReason : int {
  NO_APPROVAL_STATUS_REASON = 0,
  WATER_NOT_DRAINED_TILL_15_CM = 1,
  FIELD_IS_STILL_FLOODED = 2,
  IMAGE_NOT_CLEAR = 3,
  OUTSIDE_OF_EVENT_TIMELINE = 4,
  PICTURE_IS_NOT_OF_PIPE = 5,
  OTHERS = 6,
  MULTIPLE_REASONS = 7,
  PIPE_TOO_SMALL_IN_THE_IMAGE = 8,
  IMAGE_CLICKED_FROM_SIDE = 9,
  IMAGE_CLICKED_FROM_INSIDE_THE_PIPE = 10,
  NO_RULER = 11,
  RULER_PROTRUDING_OUT_OF_PIPE = 12,
  RULER_ROOTED_IN_GROUND = 13,
  WATER_ABOVE_THRESHOLD = 14,
  NO_PIPE = 15,
  PIPE_INTERIOR_NOT_VISIBLE = 16,
  WATER_INSIDE_OUTSIDE_THE_PIPE = 17,
  NO_RULER_AND_NO_HOLES_VISIBLE = 18,
  DETAILS_DONT_MATCH_ENTERED_DETAILS = 19,
  IMAGE_IS_NOT_OF_LAND_RECORD = 20,
  ApprovalStatusReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ApprovalStatusReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ApprovalStatusReason_IsValid(int value);
constexpr ApprovalStatusReason ApprovalStatusReason_MIN = NO_APPROVAL_STATUS_REASON;
constexpr ApprovalStatusReason ApprovalStatusReason_MAX = IMAGE_IS_NOT_OF_LAND_RECORD;
constexpr int ApprovalStatusReason_ARRAYSIZE = ApprovalStatusReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ApprovalStatusReason_descriptor();
template<typename T>
inline const std::string& ApprovalStatusReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ApprovalStatusReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ApprovalStatusReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ApprovalStatusReason_descriptor(), enum_t_value);
}
inline bool ApprovalStatusReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApprovalStatusReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ApprovalStatusReason>(
    ApprovalStatusReason_descriptor(), name, value);
}
enum ProgramType : int {
  NO_PROGRAM_TYPE = 0,
  PUSA_SPRAY_PROGRAM = 1,
  AWD_PROGRAM = 2,
  DSR_PROGRAM = 3,
  GROUNDNUT_PROGRAM = 4,
  CRM_PROGRAM = 5,
  BENGALGRAM_TRADE_PROGRAM = 6,
  AWD_22_KHARIF_PROGRAM = 7,
  CRM_22_KHARIF_PROGRAM = 8,
  DSR_22_KHARIF_PROGRAM = 9,
  SUGARCANE_PROGRAM_22 = 10,
  SOYABEAN_TRADE_PROGRAM = 11,
  RED_GRAM_TRADE_PROGRAM = 12,
  AWD_22_RABI_PROGRAM = 13,
  HORTICULTURE_PROGRAM_22 = 14,
  ProgramType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProgramType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProgramType_IsValid(int value);
constexpr ProgramType ProgramType_MIN = NO_PROGRAM_TYPE;
constexpr ProgramType ProgramType_MAX = HORTICULTURE_PROGRAM_22;
constexpr int ProgramType_ARRAYSIZE = ProgramType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProgramType_descriptor();
template<typename T>
inline const std::string& ProgramType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProgramType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProgramType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProgramType_descriptor(), enum_t_value);
}
inline bool ProgramType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProgramType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProgramType>(
    ProgramType_descriptor(), name, value);
}
enum ProgramCategory : int {
  NO_PROGRAM_CATEGORY = 0,
  AWD_CATEGORY = 1,
  DSR_CATEGORY = 2,
  CRM_CATEGORY = 3,
  TRADE_CATEGORY = 4,
  ProgramCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProgramCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProgramCategory_IsValid(int value);
constexpr ProgramCategory ProgramCategory_MIN = NO_PROGRAM_CATEGORY;
constexpr ProgramCategory ProgramCategory_MAX = TRADE_CATEGORY;
constexpr int ProgramCategory_ARRAYSIZE = ProgramCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProgramCategory_descriptor();
template<typename T>
inline const std::string& ProgramCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProgramCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProgramCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProgramCategory_descriptor(), enum_t_value);
}
inline bool ProgramCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProgramCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProgramCategory>(
    ProgramCategory_descriptor(), name, value);
}
enum ProgramStatus : int {
  NO_PROGRAM_STATUS = 0,
  PROGRAM_ENABLED = 1,
  PROGRAM_DISABLED = 2,
  ProgramStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProgramStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProgramStatus_IsValid(int value);
constexpr ProgramStatus ProgramStatus_MIN = NO_PROGRAM_STATUS;
constexpr ProgramStatus ProgramStatus_MAX = PROGRAM_DISABLED;
constexpr int ProgramStatus_ARRAYSIZE = ProgramStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProgramStatus_descriptor();
template<typename T>
inline const std::string& ProgramStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProgramStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProgramStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProgramStatus_descriptor(), enum_t_value);
}
inline bool ProgramStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProgramStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProgramStatus>(
    ProgramStatus_descriptor(), name, value);
}
enum EventName : int {
  NO_EVENT_NAME = 0,
  DRYING_EVENT_1 = 1,
  DRYING_EVENT_2 = 2,
  REGISTRATION = 3,
  DETAILS = 4,
  SOIL_TURNING = 5,
  ROTAVATOR_USAGE = 6,
  PIPE_INSTALLATION = 7,
  DRYING_EVENT = 8,
  DSR_PICTURE_UPLOAD = 9,
  DRYING_EVENT_3 = 10,
  CENTRE_OF_BUND = 11,
  FARMER_GAINEXA_PHOTO = 12,
  FARMER_LAND_RECORD_PHOTO = 13,
  EventName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EventName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EventName_IsValid(int value);
constexpr EventName EventName_MIN = NO_EVENT_NAME;
constexpr EventName EventName_MAX = FARMER_LAND_RECORD_PHOTO;
constexpr int EventName_ARRAYSIZE = EventName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventName_descriptor();
template<typename T>
inline const std::string& EventName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventName_descriptor(), enum_t_value);
}
inline bool EventName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventName>(
    EventName_descriptor(), name, value);
}
enum EventCategory : int {
  NO_EVENT_CATEGORY = 0,
  VIDEO_DATA = 1,
  IMAGE_UPLOAD = 2,
  TEXT_DATA = 3,
  GEOFENCING = 4,
  LANDOWNER = 5,
  SIGNUP = 6,
  EventCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EventCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EventCategory_IsValid(int value);
constexpr EventCategory EventCategory_MIN = NO_EVENT_CATEGORY;
constexpr EventCategory EventCategory_MAX = SIGNUP;
constexpr int EventCategory_ARRAYSIZE = EventCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventCategory_descriptor();
template<typename T>
inline const std::string& EventCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventCategory_descriptor(), enum_t_value);
}
inline bool EventCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventCategory>(
    EventCategory_descriptor(), name, value);
}
enum ProgramPageEventType : int {
  NO_EVENT_TYPE = 0,
  AWD_DRY_EVENT_1 = 1,
  AWD_DRY_EVENT_2 = 2,
  DSR_DRY_EVENT_1 = 3,
  DSR_DRY_EVENT_2 = 4,
  AWD_DRY_EVENT_3 = 5,
  AWD_DRY_EVENT_4 = 6,
  DSR_DRY_EVENT = 7,
  CRM_PROGRAM_REGISTRATION = 8,
  PUSA_SPRAY_DETAILS = 9,
  DAY_AFTER_PUSA_SPRAY_EVENT = 10,
  SOIL_TURNING_EVENT = 11,
  ROTAVATOR_USAGE_DURING_RAINS = 12,
  VIDEO_INFO = 13,
  SIGNUP_EVENT = 14,
  BEFORE_AERATION_EVENT = 15,
  GEOTAGGING = 16,
  AWD_DRY_EVENT_1_KHARIF_22 = 17,
  AWD_DRY_EVENT_2_KHARIF_22 = 18,
  BEFORE_AERATION_EVENT_KHARIF_22 = 19,
  SOIL_TURNING_EVENT_KHARIF_22 = 20,
  DAY_AFTER_PUSA_SPRAY_EVENT_KHARIF_22 = 21,
  AWD_SIGNUP_EVENT_KHARIF_22 = 22,
  GEOTAGGING_KHARIF_22 = 23,
  DSR_POST_SIGNUP_KHARIF_22 = 24,
  LANDOWNER_DETAILS_KHARIF_22 = 25,
  DSR_SIGNUP_EVENT_KHARIF_22 = 26,
  CRM_SIGNUP_EVENT_KHARIF_22 = 27,
  AWD_DRY_EVENT_3_KHARIF_22 = 28,
  AWD_CENTRE_OF_BUND_KHARIF_22 = 29,
  AWD_FARMER_GAINEXA_PHOTO_KHARIF_22 = 30,
  SUGARCANE_PROGRAM_LANDOWNER_DETAILS_22 = 31,
  SUGARCANE_PROGRAM_SIGNUP_EVENT_22 = 32,
  DSR_CENTRE_OF_BUND_KHARIF_22 = 33,
  CRM_CENTRE_OF_BUND_KHARIF_22 = 34,
  AWD_DRY_EVENT_1_RABI_22 = 41,
  AWD_DRY_EVENT_2_RABI_22 = 42,
  BEFORE_AERATION_EVENT_RABI_22 = 43,
  AWD_SIGNUP_EVENT_RABI_22 = 44,
  GEOTAGGING_RABI_22 = 45,
  LANDOWNER_DETAILS_RABI_22 = 46,
  AWD_DRY_EVENT_3_RABI_22 = 47,
  AWD_CENTRE_OF_BUND_RABI_22 = 48,
  AWD_FARMER_GAINEXA_PHOTO_RABI_22 = 49,
  HORTICULTURE_PROGRAM_LANDOWNER_DETAILS_22 = 50,
  HORTICULTURE_PROGRAM_SIGNUP_EVENT_22 = 51,
  AWD_FARMER_LAND_RECORD_PHOTO_RABI_22 = 52,
  ProgramPageEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProgramPageEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProgramPageEventType_IsValid(int value);
constexpr ProgramPageEventType ProgramPageEventType_MIN = NO_EVENT_TYPE;
constexpr ProgramPageEventType ProgramPageEventType_MAX = AWD_FARMER_LAND_RECORD_PHOTO_RABI_22;
constexpr int ProgramPageEventType_ARRAYSIZE = ProgramPageEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProgramPageEventType_descriptor();
template<typename T>
inline const std::string& ProgramPageEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProgramPageEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProgramPageEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProgramPageEventType_descriptor(), enum_t_value);
}
inline bool ProgramPageEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProgramPageEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProgramPageEventType>(
    ProgramPageEventType_descriptor(), name, value);
}
enum ProgramLocationConfig : int {
  BOTH_CONFIG = 0,
  USER_LOCATION_CONFIG = 1,
  FARM_LOCATION_CONFIG = 2,
  ProgramLocationConfig_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProgramLocationConfig_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProgramLocationConfig_IsValid(int value);
constexpr ProgramLocationConfig ProgramLocationConfig_MIN = BOTH_CONFIG;
constexpr ProgramLocationConfig ProgramLocationConfig_MAX = FARM_LOCATION_CONFIG;
constexpr int ProgramLocationConfig_ARRAYSIZE = ProgramLocationConfig_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProgramLocationConfig_descriptor();
template<typename T>
inline const std::string& ProgramLocationConfig_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProgramLocationConfig>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProgramLocationConfig_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProgramLocationConfig_descriptor(), enum_t_value);
}
inline bool ProgramLocationConfig_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProgramLocationConfig* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProgramLocationConfig>(
    ProgramLocationConfig_descriptor(), name, value);
}
enum GeofencingStatus : int {
  NO_GEOFENCING_STATUS = 0,
  GEOFENCING_PENDING = 1,
  GEOFENCING_SAVED = 2,
  GeofencingStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeofencingStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeofencingStatus_IsValid(int value);
constexpr GeofencingStatus GeofencingStatus_MIN = NO_GEOFENCING_STATUS;
constexpr GeofencingStatus GeofencingStatus_MAX = GEOFENCING_SAVED;
constexpr int GeofencingStatus_ARRAYSIZE = GeofencingStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeofencingStatus_descriptor();
template<typename T>
inline const std::string& GeofencingStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeofencingStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeofencingStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeofencingStatus_descriptor(), enum_t_value);
}
inline bool GeofencingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeofencingStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeofencingStatus>(
    GeofencingStatus_descriptor(), name, value);
}
enum EventStatus : int {
  NO_EVENT_STATUS = 0,
  EVENT_ENABLED = 1,
  EVENT_DISABLED = 2,
  EventStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EventStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EventStatus_IsValid(int value);
constexpr EventStatus EventStatus_MIN = NO_EVENT_STATUS;
constexpr EventStatus EventStatus_MAX = EVENT_DISABLED;
constexpr int EventStatus_ARRAYSIZE = EventStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventStatus_descriptor();
template<typename T>
inline const std::string& EventStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventStatus_descriptor(), enum_t_value);
}
inline bool EventStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventStatus>(
    EventStatus_descriptor(), name, value);
}
enum ContactType : int {
  NO_CONTACT_TYPE = 0,
  EMAIL_ID = 1,
  MOBILE_NUMBER = 2,
  FCM_TOKEN = 3,
  ContactType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ContactType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ContactType_IsValid(int value);
constexpr ContactType ContactType_MIN = NO_CONTACT_TYPE;
constexpr ContactType ContactType_MAX = FCM_TOKEN;
constexpr int ContactType_ARRAYSIZE = ContactType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContactType_descriptor();
template<typename T>
inline const std::string& ContactType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContactType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContactType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContactType_descriptor(), enum_t_value);
}
inline bool ContactType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContactType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContactType>(
    ContactType_descriptor(), name, value);
}
enum CampaignStatus : int {
  NO_CAMPAGIN_STATUS = 0,
  RUNNING = 1,
  HALTED = 2,
  PRE_INACTION = 3,
  DRAFTED = 4,
  CampaignStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CampaignStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CampaignStatus_IsValid(int value);
constexpr CampaignStatus CampaignStatus_MIN = NO_CAMPAGIN_STATUS;
constexpr CampaignStatus CampaignStatus_MAX = DRAFTED;
constexpr int CampaignStatus_ARRAYSIZE = CampaignStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CampaignStatus_descriptor();
template<typename T>
inline const std::string& CampaignStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CampaignStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CampaignStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CampaignStatus_descriptor(), enum_t_value);
}
inline bool CampaignStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CampaignStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CampaignStatus>(
    CampaignStatus_descriptor(), name, value);
}
enum NameSpace : int {
  NO_NAMESPACE = 0,
  FARM = 1,
  RETAIL = 2,
  TRADE = 3,
  SUSTAIN = 4,
  NURTURE_PARTNER = 5,
  INSURANCE = 6,
  NameSpace_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NameSpace_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NameSpace_IsValid(int value);
constexpr NameSpace NameSpace_MIN = NO_NAMESPACE;
constexpr NameSpace NameSpace_MAX = INSURANCE;
constexpr int NameSpace_ARRAYSIZE = NameSpace_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NameSpace_descriptor();
template<typename T>
inline const std::string& NameSpace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NameSpace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NameSpace_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NameSpace_descriptor(), enum_t_value);
}
inline bool NameSpace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NameSpace* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NameSpace>(
    NameSpace_descriptor(), name, value);
}
enum CampaignQueryType : int {
  NO_CAMPAIGN_QUERY_TYPE = 0,
  ATHENA = 1,
  DATABASE = 2,
  USER_LIST = 3,
  USER_JOURNEY = 4,
  CampaignQueryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CampaignQueryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CampaignQueryType_IsValid(int value);
constexpr CampaignQueryType CampaignQueryType_MIN = NO_CAMPAIGN_QUERY_TYPE;
constexpr CampaignQueryType CampaignQueryType_MAX = USER_JOURNEY;
constexpr int CampaignQueryType_ARRAYSIZE = CampaignQueryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CampaignQueryType_descriptor();
template<typename T>
inline const std::string& CampaignQueryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CampaignQueryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CampaignQueryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CampaignQueryType_descriptor(), enum_t_value);
}
inline bool CampaignQueryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CampaignQueryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CampaignQueryType>(
    CampaignQueryType_descriptor(), name, value);
}
enum CampaignQueryMappingType : int {
  NO_QUERY_MAPPING_TYPE = 0,
  USER_DEFINED = 1,
  BUSINESS_DEFINED = 2,
  CUSTOM_QUERY = 3,
  CampaignQueryMappingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CampaignQueryMappingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CampaignQueryMappingType_IsValid(int value);
constexpr CampaignQueryMappingType CampaignQueryMappingType_MIN = NO_QUERY_MAPPING_TYPE;
constexpr CampaignQueryMappingType CampaignQueryMappingType_MAX = CUSTOM_QUERY;
constexpr int CampaignQueryMappingType_ARRAYSIZE = CampaignQueryMappingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CampaignQueryMappingType_descriptor();
template<typename T>
inline const std::string& CampaignQueryMappingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CampaignQueryMappingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CampaignQueryMappingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CampaignQueryMappingType_descriptor(), enum_t_value);
}
inline bool CampaignQueryMappingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CampaignQueryMappingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CampaignQueryMappingType>(
    CampaignQueryMappingType_descriptor(), name, value);
}
enum ReferralBookingType : int {
  REFERRAL_SPRAY_BOOKING = 0,
  REFERRAL_PRODUCT_SCAN = 1,
  REFERRAL_PROGRAM_ENROLLMENT = 2,
  ReferralBookingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ReferralBookingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ReferralBookingType_IsValid(int value);
constexpr ReferralBookingType ReferralBookingType_MIN = REFERRAL_SPRAY_BOOKING;
constexpr ReferralBookingType ReferralBookingType_MAX = REFERRAL_PROGRAM_ENROLLMENT;
constexpr int ReferralBookingType_ARRAYSIZE = ReferralBookingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReferralBookingType_descriptor();
template<typename T>
inline const std::string& ReferralBookingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReferralBookingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReferralBookingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReferralBookingType_descriptor(), enum_t_value);
}
inline bool ReferralBookingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReferralBookingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReferralBookingType>(
    ReferralBookingType_descriptor(), name, value);
}
enum ReferralType : int {
  NO_REFERRAL = 0,
  EXISTING_REFERRAL = 1,
  CUSTOM_REFERRAL = 2,
  ReferralType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ReferralType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ReferralType_IsValid(int value);
constexpr ReferralType ReferralType_MIN = NO_REFERRAL;
constexpr ReferralType ReferralType_MAX = CUSTOM_REFERRAL;
constexpr int ReferralType_ARRAYSIZE = ReferralType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReferralType_descriptor();
template<typename T>
inline const std::string& ReferralType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReferralType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReferralType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReferralType_descriptor(), enum_t_value);
}
inline bool ReferralType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReferralType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReferralType>(
    ReferralType_descriptor(), name, value);
}
enum FormStatus : int {
  NO_FORM_STATUS = 0,
  FS_DRAFT = 1,
  FS_COMPLETED = 2,
  FS_ACTIVE = 3,
  FS_DELETED = 4,
  FormStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FormStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FormStatus_IsValid(int value);
constexpr FormStatus FormStatus_MIN = NO_FORM_STATUS;
constexpr FormStatus FormStatus_MAX = FS_DELETED;
constexpr int FormStatus_ARRAYSIZE = FormStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FormStatus_descriptor();
template<typename T>
inline const std::string& FormStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FormStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FormStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FormStatus_descriptor(), enum_t_value);
}
inline bool FormStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FormStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FormStatus>(
    FormStatus_descriptor(), name, value);
}
enum EligibilityStatus : int {
  NO_ELIGIBILITY_STATUS = 0,
  ELIGIBLE = 1,
  IN_ELIGIBLE = 2,
  UNKNOWN = 3,
  EligibilityStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EligibilityStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EligibilityStatus_IsValid(int value);
constexpr EligibilityStatus EligibilityStatus_MIN = NO_ELIGIBILITY_STATUS;
constexpr EligibilityStatus EligibilityStatus_MAX = UNKNOWN;
constexpr int EligibilityStatus_ARRAYSIZE = EligibilityStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EligibilityStatus_descriptor();
template<typename T>
inline const std::string& EligibilityStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EligibilityStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EligibilityStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EligibilityStatus_descriptor(), enum_t_value);
}
inline bool EligibilityStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EligibilityStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EligibilityStatus>(
    EligibilityStatus_descriptor(), name, value);
}
enum ServicesName : int {
  PADDY_HARVESTER = 0,
  HAPPY_SEEDER = 1,
  BAILER = 2,
  STUBBLE_CUTTER = 3,
  COMBINE_HARVESTER = 4,
  ServicesName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ServicesName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ServicesName_IsValid(int value);
constexpr ServicesName ServicesName_MIN = PADDY_HARVESTER;
constexpr ServicesName ServicesName_MAX = COMBINE_HARVESTER;
constexpr int ServicesName_ARRAYSIZE = ServicesName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServicesName_descriptor();
template<typename T>
inline const std::string& ServicesName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServicesName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServicesName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServicesName_descriptor(), enum_t_value);
}
inline bool ServicesName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServicesName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServicesName>(
    ServicesName_descriptor(), name, value);
}
enum CampaignScheduleType : int {
  NO_CAMPAIGN_SCHEDULE_TYPE = 0,
  INACTION_OVER_TIME = 1,
  DYNAMIC_MEDIA_TYPE = 2,
  CampaignScheduleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CampaignScheduleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CampaignScheduleType_IsValid(int value);
constexpr CampaignScheduleType CampaignScheduleType_MIN = NO_CAMPAIGN_SCHEDULE_TYPE;
constexpr CampaignScheduleType CampaignScheduleType_MAX = DYNAMIC_MEDIA_TYPE;
constexpr int CampaignScheduleType_ARRAYSIZE = CampaignScheduleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CampaignScheduleType_descriptor();
template<typename T>
inline const std::string& CampaignScheduleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CampaignScheduleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CampaignScheduleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CampaignScheduleType_descriptor(), enum_t_value);
}
inline bool CampaignScheduleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CampaignScheduleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CampaignScheduleType>(
    CampaignScheduleType_descriptor(), name, value);
}
enum ResourceType : int {
  NO_RESOURCE = 0,
  FARMER_ONBOARDING = 1,
  BOOKING = 2,
  PROGRAM_SIGNUP = 3,
  BANK_DEPOSIT = 4,
  ResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResourceType_IsValid(int value);
constexpr ResourceType ResourceType_MIN = NO_RESOURCE;
constexpr ResourceType ResourceType_MAX = BANK_DEPOSIT;
constexpr int ResourceType_ARRAYSIZE = ResourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResourceType_descriptor();
template<typename T>
inline const std::string& ResourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResourceType_descriptor(), enum_t_value);
}
inline bool ResourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResourceType>(
    ResourceType_descriptor(), name, value);
}
enum ResourceAccessType : int {
  NO_ACCESS = 0,
  VIEW = 1,
  CREATE = 2,
  EDIT = 3,
  DELETE = 4,
  CANCEL = 5,
  REASSIGN = 6,
  ResourceAccessType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ResourceAccessType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ResourceAccessType_IsValid(int value);
constexpr ResourceAccessType ResourceAccessType_MIN = NO_ACCESS;
constexpr ResourceAccessType ResourceAccessType_MAX = REASSIGN;
constexpr int ResourceAccessType_ARRAYSIZE = ResourceAccessType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResourceAccessType_descriptor();
template<typename T>
inline const std::string& ResourceAccessType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResourceAccessType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResourceAccessType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResourceAccessType_descriptor(), enum_t_value);
}
inline bool ResourceAccessType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResourceAccessType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResourceAccessType>(
    ResourceAccessType_descriptor(), name, value);
}
enum ContentCategory : int {
  NO_CONTENT_CATEGORY = 0,
  MEDIA_FEED = 1,
  PROGRAM_EVENT_CONTENT = 2,
  CONTENT_UPLOAD_DEMO = 3,
  INSURANCE_DEMO_CONTENT = 4,
  AGRONOMY_ADVISORY = 5,
  ContentCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ContentCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ContentCategory_IsValid(int value);
constexpr ContentCategory ContentCategory_MIN = NO_CONTENT_CATEGORY;
constexpr ContentCategory ContentCategory_MAX = AGRONOMY_ADVISORY;
constexpr int ContentCategory_ARRAYSIZE = ContentCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContentCategory_descriptor();
template<typename T>
inline const std::string& ContentCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContentCategory_descriptor(), enum_t_value);
}
inline bool ContentCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContentCategory>(
    ContentCategory_descriptor(), name, value);
}
enum ContentProvider : int {
  NO_CONTENT_PROVIDER = 0,
  YOUTUBE = 1,
  S3 = 2,
  BLOBSTORE = 3,
  ACCOUNT_MEIN = 4,
  ContentProvider_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ContentProvider_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ContentProvider_IsValid(int value);
constexpr ContentProvider ContentProvider_MIN = NO_CONTENT_PROVIDER;
constexpr ContentProvider ContentProvider_MAX = ACCOUNT_MEIN;
constexpr int ContentProvider_ARRAYSIZE = ContentProvider_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContentProvider_descriptor();
template<typename T>
inline const std::string& ContentProvider_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentProvider>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentProvider_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContentProvider_descriptor(), enum_t_value);
}
inline bool ContentProvider_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentProvider* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContentProvider>(
    ContentProvider_descriptor(), name, value);
}
enum PayoutProcessType : int {
  NO_PAYOUT_PROCESS_TYPE = 0,
  REPROCESS = 1,
  UPDATE = 2,
  PayoutProcessType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PayoutProcessType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PayoutProcessType_IsValid(int value);
constexpr PayoutProcessType PayoutProcessType_MIN = NO_PAYOUT_PROCESS_TYPE;
constexpr PayoutProcessType PayoutProcessType_MAX = UPDATE;
constexpr int PayoutProcessType_ARRAYSIZE = PayoutProcessType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PayoutProcessType_descriptor();
template<typename T>
inline const std::string& PayoutProcessType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PayoutProcessType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PayoutProcessType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PayoutProcessType_descriptor(), enum_t_value);
}
inline bool PayoutProcessType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PayoutProcessType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PayoutProcessType>(
    PayoutProcessType_descriptor(), name, value);
}
enum JobType : int {
  NO_JOB_TYPE = 0,
  JOB_TYPE_RETAILER_ONBOARDING = 1,
  JOB_TYPE_ORDER_CREATION = 2,
  JOB_TYPE_FARMER_ONBOARDING = 3,
  JOB_TYPE_PRODUCT_SCAN = 4,
  JOB_TYPE_SERVICE_BOOKING = 5,
  JOB_TYPE_HEALTH_PACKAGE = 6,
  JOB_TYPE_AWD_ONBOARDED = 7,
  JOB_TYPE_DSR_ONBOARDED = 8,
  JOB_TYPE_PRODUCT_INTEREST = 9,
  JOB_TYPE_PIPE_INSTALLED = 11,
  JOB_TYPE_ACRES_SERVICED = 12,
  JOB_TYPE_GEOFENCING = 13,
  JOB_TYPE_DRYING_EVENT_1 = 14,
  JOB_TYPE_DRYING_EVENT_2 = 15,
  JOB_TYPE_WEATHER_CASH_GUARANTEE = 16,
  JOB_TYPE_DHAN_VRIDHI_PROGRAM = 17,
  JOB_TYPE_CRM_ONBOARDED_KHARIF_22 = 18,
  JOB_TYPE_DSR_ONBOARDED_KHARIF_22 = 19,
  JOB_TYPE_AWD_ONBOARDED_KHARIF_22 = 20,
  JOB_TYPE_FARMER_GAINEXA_PHOTO_KHARIF_22 = 21,
  JOB_TYPE_FARMERS_LAND_RECORD = 22,
  JOB_TYPE_PIPE_INSTALL_PICS_AWD_KHARIF_22 = 23,
  JOB_TYPE_INSIDE_PLOT_PICS_AWD_KHARIF_22 = 24,
  JOB_TYPE_PROGRAM_SIGNUPS_SUGARCANE = 25,
  JOB_TYPE_AERATION_EVENTS = 26,
  JOB_TYPE_DRYING_EVENT_2_KHARIF_22 = 27,
  JOB_TYPE_DRYING_EVENT_3_KHARIF_22 = 28,
  JOB_TYPE_INSIDE_PLOT_PICS_DSR_KHARIF_22 = 29,
  JOB_TYPE_SOYA_TRADE_SIGNUP_PROGRAM = 30,
  JOB_TYPE_OPERATOR_SERVICES = 31,
  JOB_TYPE_AWD_ONBOARDED_RABI_22 = 33,
  JOB_TYPE_PIPE_INSTALLED_RABI_22 = 34,
  JOB_TYPE_GEOFENCING_RABI_22 = 35,
  JOB_TYPE_SURVEY_RECORD_RABI_22 = 36,
  JOB_TYPE_AERATION_EVENTS_1_RABI_22 = 37,
  JOB_TYPE_AERATION_EVENTS_2_RABI_22 = 38,
  JOB_TYPE_DATA_COLLECTION_RABI_22 = 39,
  JOB_TYPE_BOTTOM_OF_FUNNEL_RABI_22 = 40,
  JOB_TYPE_D2F = 41,
  JOB_TYPE_D2F_ORDER_CREATION = 42,
  JOB_TYPE_INSIDE_PLOT_PICS_AWD_RABI_22 = 43,
  JOB_TYPE_DRYING_EVENT_1_RABI_22 = 44,
  JOB_TYPE_DRYING_EVENT_2_RABI_22 = 45,
  JobType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  JobType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool JobType_IsValid(int value);
constexpr JobType JobType_MIN = NO_JOB_TYPE;
constexpr JobType JobType_MAX = JOB_TYPE_DRYING_EVENT_2_RABI_22;
constexpr int JobType_ARRAYSIZE = JobType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobType_descriptor();
template<typename T>
inline const std::string& JobType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobType_descriptor(), enum_t_value);
}
inline bool JobType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobType>(
    JobType_descriptor(), name, value);
}
enum JobStatus : int {
  NO_Job_Status = 0,
  JOB_STATUS_TO_DO = 1,
  JOB_STATUS_STARTED = 2,
  JOB_STATUS_PARTIAL = 3,
  JOB_STATUS_COMPLETED = 4,
  JOB_STATUS_CANCELLED = 5,
  JOB_STATUS_PENDING = 6,
  JOB_STATUS_UNFULFILLED = 7,
  JobStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  JobStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool JobStatus_IsValid(int value);
constexpr JobStatus JobStatus_MIN = NO_Job_Status;
constexpr JobStatus JobStatus_MAX = JOB_STATUS_UNFULFILLED;
constexpr int JobStatus_ARRAYSIZE = JobStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JobStatus_descriptor();
template<typename T>
inline const std::string& JobStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JobStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JobStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JobStatus_descriptor(), enum_t_value);
}
inline bool JobStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JobStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JobStatus>(
    JobStatus_descriptor(), name, value);
}
enum PaymentStatus : int {
  NO_PAYMENT_STATUS = 0,
  PAYMENT_CREATED = 1,
  PAYMENT_PAID = 2,
  PAYMENT_ON_HOLD = 3,
  PAYMENT_VOID = 4,
  PaymentStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PaymentStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PaymentStatus_IsValid(int value);
constexpr PaymentStatus PaymentStatus_MIN = NO_PAYMENT_STATUS;
constexpr PaymentStatus PaymentStatus_MAX = PAYMENT_VOID;
constexpr int PaymentStatus_ARRAYSIZE = PaymentStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaymentStatus_descriptor();
template<typename T>
inline const std::string& PaymentStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaymentStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaymentStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaymentStatus_descriptor(), enum_t_value);
}
inline bool PaymentStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaymentStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaymentStatus>(
    PaymentStatus_descriptor(), name, value);
}
enum PaymentReason : int {
  UNKNOWN_PAYMENT_REASON = 0,
  FARMER_ONBOARDING_PAYMENT = 1,
  PRODUCT_SCAN_PAYMENT_PAYMENT = 2,
  FARMER_SPRAY_BOOKING_PAYMENT = 3,
  RETAILER_ONBOARDING_PAYMENT = 4,
  RETAILER_FIRST_ORDER_PAYMENT = 5,
  RETAILER_SECOND_ORDER_PAYMENT = 6,
  RETAILER_ALL_ORDER_PAYMENT = 7,
  GENERAL_SCHEME_PAYMENT = 8,
  MANUAL_PAYMENT = 9,
  PaymentReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PaymentReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PaymentReason_IsValid(int value);
constexpr PaymentReason PaymentReason_MIN = UNKNOWN_PAYMENT_REASON;
constexpr PaymentReason PaymentReason_MAX = MANUAL_PAYMENT;
constexpr int PaymentReason_ARRAYSIZE = PaymentReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaymentReason_descriptor();
template<typename T>
inline const std::string& PaymentReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaymentReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaymentReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaymentReason_descriptor(), enum_t_value);
}
inline bool PaymentReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaymentReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaymentReason>(
    PaymentReason_descriptor(), name, value);
}
enum SchemeType : int {
  SCHEME_TYPE_UNKNOWN = 0,
  SCHEME_TYPE_FIXED_PAY_SCHEME = 1,
  SCHEME_TYPE_VARIABLE_PAY_SCHEME = 2,
  SCHEME_TYPE_RECURRING_SCHEME = 3,
  SchemeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SchemeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SchemeType_IsValid(int value);
constexpr SchemeType SchemeType_MIN = SCHEME_TYPE_UNKNOWN;
constexpr SchemeType SchemeType_MAX = SCHEME_TYPE_RECURRING_SCHEME;
constexpr int SchemeType_ARRAYSIZE = SchemeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SchemeType_descriptor();
template<typename T>
inline const std::string& SchemeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SchemeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SchemeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SchemeType_descriptor(), enum_t_value);
}
inline bool SchemeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SchemeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SchemeType>(
    SchemeType_descriptor(), name, value);
}
enum SchemeWindowType : int {
  SCHEME_WINDOW_TYPE_UNKNOWN = 0,
  SCHEME_WINDOW_TYPE_DAILY = 1,
  SCHEME_WINDOW_TYPE_WEEKLY = 2,
  SCHEME_WINDOW_TYPE_MONTHLY = 3,
  SchemeWindowType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SchemeWindowType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SchemeWindowType_IsValid(int value);
constexpr SchemeWindowType SchemeWindowType_MIN = SCHEME_WINDOW_TYPE_UNKNOWN;
constexpr SchemeWindowType SchemeWindowType_MAX = SCHEME_WINDOW_TYPE_MONTHLY;
constexpr int SchemeWindowType_ARRAYSIZE = SchemeWindowType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SchemeWindowType_descriptor();
template<typename T>
inline const std::string& SchemeWindowType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SchemeWindowType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SchemeWindowType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SchemeWindowType_descriptor(), enum_t_value);
}
inline bool SchemeWindowType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SchemeWindowType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SchemeWindowType>(
    SchemeWindowType_descriptor(), name, value);
}
enum PaymentType : int {
  PAYMENT_TYPE_UNKNOWN = 0,
  PAYMENT_TYPE_FLAT = 1,
  PAYMENT_TYPE_PERCENTAGE = 2,
  PAYMENT_TYPE_PER_UNIT = 3,
  PaymentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PaymentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PaymentType_IsValid(int value);
constexpr PaymentType PaymentType_MIN = PAYMENT_TYPE_UNKNOWN;
constexpr PaymentType PaymentType_MAX = PAYMENT_TYPE_PER_UNIT;
constexpr int PaymentType_ARRAYSIZE = PaymentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaymentType_descriptor();
template<typename T>
inline const std::string& PaymentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaymentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaymentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaymentType_descriptor(), enum_t_value);
}
inline bool PaymentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaymentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaymentType>(
    PaymentType_descriptor(), name, value);
}
enum PerformanceQueryType : int {
  NO_QUERY = 0,
  QUERY_ATHENA = 1,
  QUERY_MYSQL = 2,
  QUERY_PRESTO = 3,
  QUERY_TRINO = 4,
  PerformanceQueryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PerformanceQueryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PerformanceQueryType_IsValid(int value);
constexpr PerformanceQueryType PerformanceQueryType_MIN = NO_QUERY;
constexpr PerformanceQueryType PerformanceQueryType_MAX = QUERY_TRINO;
constexpr int PerformanceQueryType_ARRAYSIZE = PerformanceQueryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerformanceQueryType_descriptor();
template<typename T>
inline const std::string& PerformanceQueryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerformanceQueryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerformanceQueryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerformanceQueryType_descriptor(), enum_t_value);
}
inline bool PerformanceQueryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerformanceQueryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerformanceQueryType>(
    PerformanceQueryType_descriptor(), name, value);
}
enum PerformanceQueryMappingType : int {
  NO_QUERY_TYPE = 0,
  AGGREGATED_VIEW = 1,
  DETAILED_VIEW = 2,
  LAST_RUN_AT_QUERY = 3,
  AGGREGATED_ATTRIBUTE_VIEW = 4,
  PerformanceQueryMappingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PerformanceQueryMappingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PerformanceQueryMappingType_IsValid(int value);
constexpr PerformanceQueryMappingType PerformanceQueryMappingType_MIN = NO_QUERY_TYPE;
constexpr PerformanceQueryMappingType PerformanceQueryMappingType_MAX = AGGREGATED_ATTRIBUTE_VIEW;
constexpr int PerformanceQueryMappingType_ARRAYSIZE = PerformanceQueryMappingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerformanceQueryMappingType_descriptor();
template<typename T>
inline const std::string& PerformanceQueryMappingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerformanceQueryMappingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerformanceQueryMappingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerformanceQueryMappingType_descriptor(), enum_t_value);
}
inline bool PerformanceQueryMappingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerformanceQueryMappingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerformanceQueryMappingType>(
    PerformanceQueryMappingType_descriptor(), name, value);
}
enum PerformanceType : int {
  NO_PERFORMANCE_TYPE = 0,
  PERFORMANCE_TYPE_RETAILER_ONBOARDING = 1,
  PERFORMANCE_TYPE_FIRST_ORDERS = 2,
  PERFORMANCE_TYPE_SECOND_ORDERS = 3,
  PERFORMANCE_TYPE_ALL_ORDERS = 4,
  PERFORMANCE_TYPE_FARMER_ONBOARDING = 5,
  PERFORMANCE_TYPE_PRODUCT_SCANS = 6,
  PERFORMANCE_TYPE_ACRES_SPRAYED = 7,
  PERFORMANCE_TYPE_HEALTH_PACKAGE = 8,
  PERFORMANCE_TYPE_AWD_ONBOARDED = 9,
  PERFORMANCE_TYPE_DSR_ONBOARDED = 10,
  PERFORMANCE_TYPE_PRODUCT_INTEREST = 11,
  PERFORMANCE_TYPE_PIPE_INSTALLED = 12,
  PERFORMANCE_TYPE_ACRES_SERVICED = 13,
  PERFORMANCE_TYPE_GEOFENCING = 14,
  PERFORMANCE_TYPE_DRYING_EVENT_1 = 15,
  PERFORMANCE_TYPE_DRYING_EVENT_2 = 16,
  PERFORMANCE_TYPE_WEATHER_CASH_GUARANTEE = 17,
  PERFORMANCE_TYPE_DHAN_VRIDHI_PROGRAM = 18,
  PerformanceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PerformanceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PerformanceType_IsValid(int value);
constexpr PerformanceType PerformanceType_MIN = NO_PERFORMANCE_TYPE;
constexpr PerformanceType PerformanceType_MAX = PERFORMANCE_TYPE_DHAN_VRIDHI_PROGRAM;
constexpr int PerformanceType_ARRAYSIZE = PerformanceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PerformanceType_descriptor();
template<typename T>
inline const std::string& PerformanceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PerformanceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PerformanceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PerformanceType_descriptor(), enum_t_value);
}
inline bool PerformanceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PerformanceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PerformanceType>(
    PerformanceType_descriptor(), name, value);
}
enum ContentDataCategory : int {
  PRODUCT_USAGE = 0,
  FARMING_TECHNIQUE = 1,
  CROP_ADVISORY = 2,
  CROP_SELECTION = 3,
  AWARENESS = 4,
  FARMER_TESTIMONIAL = 5,
  FARMING_MACHINERY = 6,
  CARBON_PROGRAM = 7,
  SELFIE_CONTEST = 8,
  FARM_DIARY = 9,
  OTHERS_CATEGORY = 10,
  CROP_DOCTOR = 11,
  ContentDataCategory_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ContentDataCategory_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ContentDataCategory_IsValid(int value);
constexpr ContentDataCategory ContentDataCategory_MIN = PRODUCT_USAGE;
constexpr ContentDataCategory ContentDataCategory_MAX = CROP_DOCTOR;
constexpr int ContentDataCategory_ARRAYSIZE = ContentDataCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContentDataCategory_descriptor();
template<typename T>
inline const std::string& ContentDataCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentDataCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentDataCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContentDataCategory_descriptor(), enum_t_value);
}
inline bool ContentDataCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentDataCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContentDataCategory>(
    ContentDataCategory_descriptor(), name, value);
}
enum IOTBookingAction : int {
  NO_ACTION = 0,
  START = 1,
  STOP = 2,
  PAUSE = 3,
  RESUME = 4,
  IOTBookingAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  IOTBookingAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool IOTBookingAction_IsValid(int value);
constexpr IOTBookingAction IOTBookingAction_MIN = NO_ACTION;
constexpr IOTBookingAction IOTBookingAction_MAX = RESUME;
constexpr int IOTBookingAction_ARRAYSIZE = IOTBookingAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IOTBookingAction_descriptor();
template<typename T>
inline const std::string& IOTBookingAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IOTBookingAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IOTBookingAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IOTBookingAction_descriptor(), enum_t_value);
}
inline bool IOTBookingAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IOTBookingAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IOTBookingAction>(
    IOTBookingAction_descriptor(), name, value);
}
enum TargetUserWorkflowQueryMappingType : int {
  NO_TARGET_USERS_QUERY = 0,
  TARGET_USERS_AGGREGATED_VIEW = 1,
  TARGET_USERS_LIST_VIEW = 2,
  TargetUserWorkflowQueryMappingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TargetUserWorkflowQueryMappingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TargetUserWorkflowQueryMappingType_IsValid(int value);
constexpr TargetUserWorkflowQueryMappingType TargetUserWorkflowQueryMappingType_MIN = NO_TARGET_USERS_QUERY;
constexpr TargetUserWorkflowQueryMappingType TargetUserWorkflowQueryMappingType_MAX = TARGET_USERS_LIST_VIEW;
constexpr int TargetUserWorkflowQueryMappingType_ARRAYSIZE = TargetUserWorkflowQueryMappingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TargetUserWorkflowQueryMappingType_descriptor();
template<typename T>
inline const std::string& TargetUserWorkflowQueryMappingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TargetUserWorkflowQueryMappingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TargetUserWorkflowQueryMappingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TargetUserWorkflowQueryMappingType_descriptor(), enum_t_value);
}
inline bool TargetUserWorkflowQueryMappingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TargetUserWorkflowQueryMappingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TargetUserWorkflowQueryMappingType>(
    TargetUserWorkflowQueryMappingType_descriptor(), name, value);
}
enum QuestionnaireType : int {
  NO_QUESTIONNAIRE_TYPE = 0,
  POLLS = 1,
  QUIZZES = 2,
  DAILY_QUIZ = 3,
  TEXT_OVER_IMAGE = 4,
  QuestionnaireType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  QuestionnaireType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool QuestionnaireType_IsValid(int value);
constexpr QuestionnaireType QuestionnaireType_MIN = NO_QUESTIONNAIRE_TYPE;
constexpr QuestionnaireType QuestionnaireType_MAX = TEXT_OVER_IMAGE;
constexpr int QuestionnaireType_ARRAYSIZE = QuestionnaireType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestionnaireType_descriptor();
template<typename T>
inline const std::string& QuestionnaireType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestionnaireType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestionnaireType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestionnaireType_descriptor(), enum_t_value);
}
inline bool QuestionnaireType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestionnaireType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestionnaireType>(
    QuestionnaireType_descriptor(), name, value);
}
enum SelectType : int {
  RADIO = 0,
  CHECKBOX = 1,
  SelectType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SelectType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SelectType_IsValid(int value);
constexpr SelectType SelectType_MIN = RADIO;
constexpr SelectType SelectType_MAX = CHECKBOX;
constexpr int SelectType_ARRAYSIZE = SelectType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SelectType_descriptor();
template<typename T>
inline const std::string& SelectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SelectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SelectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SelectType_descriptor(), enum_t_value);
}
inline bool SelectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SelectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SelectType>(
    SelectType_descriptor(), name, value);
}
enum QuestionnaireStatus : int {
  QUESTIONNAIRE_ACTIVE = 0,
  QUESTIONNAIRE_ALL = 1,
  QUESTIONNAIRE_DELETED = 2,
  QuestionnaireStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  QuestionnaireStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool QuestionnaireStatus_IsValid(int value);
constexpr QuestionnaireStatus QuestionnaireStatus_MIN = QUESTIONNAIRE_ACTIVE;
constexpr QuestionnaireStatus QuestionnaireStatus_MAX = QUESTIONNAIRE_DELETED;
constexpr int QuestionnaireStatus_ARRAYSIZE = QuestionnaireStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuestionnaireStatus_descriptor();
template<typename T>
inline const std::string& QuestionnaireStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuestionnaireStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuestionnaireStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuestionnaireStatus_descriptor(), enum_t_value);
}
inline bool QuestionnaireStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QuestionnaireStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuestionnaireStatus>(
    QuestionnaireStatus_descriptor(), name, value);
}
enum ContentTagEnum : int {
  ContentTagEnum_CATEGORY = 0,
  ContentTagEnum_CROP = 1,
  ContentTagEnum_PRODUCT = 2,
  ContentTagEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ContentTagEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ContentTagEnum_IsValid(int value);
constexpr ContentTagEnum ContentTagEnum_MIN = ContentTagEnum_CATEGORY;
constexpr ContentTagEnum ContentTagEnum_MAX = ContentTagEnum_PRODUCT;
constexpr int ContentTagEnum_ARRAYSIZE = ContentTagEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContentTagEnum_descriptor();
template<typename T>
inline const std::string& ContentTagEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentTagEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentTagEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContentTagEnum_descriptor(), enum_t_value);
}
inline bool ContentTagEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentTagEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContentTagEnum>(
    ContentTagEnum_descriptor(), name, value);
}
enum CommunicationVendor : int {
  NO_VENDOR = 0,
  KARIX = 1,
  GUPSHUP = 2,
  FIREBASE = 3,
  CommunicationVendor_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CommunicationVendor_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CommunicationVendor_IsValid(int value);
constexpr CommunicationVendor CommunicationVendor_MIN = NO_VENDOR;
constexpr CommunicationVendor CommunicationVendor_MAX = FIREBASE;
constexpr int CommunicationVendor_ARRAYSIZE = CommunicationVendor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommunicationVendor_descriptor();
template<typename T>
inline const std::string& CommunicationVendor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommunicationVendor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommunicationVendor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CommunicationVendor_descriptor(), enum_t_value);
}
inline bool CommunicationVendor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommunicationVendor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CommunicationVendor>(
    CommunicationVendor_descriptor(), name, value);
}
enum PartnerUploadType : int {
  BULK_UPLOAD_PARTNER_DATA = 0,
  BULK_UPLOAD_PARTNER_ROLE_DATA = 1,
  BULK_UPLOAD_PARTNER_SUPERVISOR_DATA = 2,
  BULK_UPLOAD_S3_FARMER_MAPPING_DATA = 3,
  BULK_UPLOAD_INSURANCE_SCHEMES_DATA = 4,
  BULK_UPLOAD_INSURANCE_OFFERS_DATA = 5,
  BULK_UPLOAD_INSURANCE_OFFER_SCHEME_MAPPING_DATA = 6,
  BULK_UPLOAD_INSURANCE_CLAIMS_DATA = 7,
  BULK_UPLOAD_INSURANCE_BULK_ISSUE_SCHEME_DATA = 8,
  BULK_UPLOAD_ADHOC_TRANSACTION_MAKER_DATA = 9,
  BULK_UPLOAD_POSP_CERTIFICATION_DATA = 10,
  BULK_UPLOAD_ADHOC_TRANSACTION_CHECKER_DATA = 11,
  PartnerUploadType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PartnerUploadType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PartnerUploadType_IsValid(int value);
constexpr PartnerUploadType PartnerUploadType_MIN = BULK_UPLOAD_PARTNER_DATA;
constexpr PartnerUploadType PartnerUploadType_MAX = BULK_UPLOAD_ADHOC_TRANSACTION_CHECKER_DATA;
constexpr int PartnerUploadType_ARRAYSIZE = PartnerUploadType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartnerUploadType_descriptor();
template<typename T>
inline const std::string& PartnerUploadType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartnerUploadType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartnerUploadType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartnerUploadType_descriptor(), enum_t_value);
}
inline bool PartnerUploadType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PartnerUploadType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartnerUploadType>(
    PartnerUploadType_descriptor(), name, value);
}
enum PartnerUploadStatus : int {
  PARTNER_UPLOAD_PENDING = 0,
  PARTNER_UPLOAD_IN_PROGRESS = 1,
  PARTNER_UPLOAD_COMPLETED = 2,
  PartnerUploadStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PartnerUploadStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PartnerUploadStatus_IsValid(int value);
constexpr PartnerUploadStatus PartnerUploadStatus_MIN = PARTNER_UPLOAD_PENDING;
constexpr PartnerUploadStatus PartnerUploadStatus_MAX = PARTNER_UPLOAD_COMPLETED;
constexpr int PartnerUploadStatus_ARRAYSIZE = PartnerUploadStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartnerUploadStatus_descriptor();
template<typename T>
inline const std::string& PartnerUploadStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartnerUploadStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartnerUploadStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartnerUploadStatus_descriptor(), enum_t_value);
}
inline bool PartnerUploadStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PartnerUploadStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartnerUploadStatus>(
    PartnerUploadStatus_descriptor(), name, value);
}
enum PaymentMethod : int {
  CASH = 0,
  WALLET = 1,
  UPI = 2,
  PRODUCT_SCAN_OFFER = 3,
  OFFER = 4,
  PaymentMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PaymentMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PaymentMethod_IsValid(int value);
constexpr PaymentMethod PaymentMethod_MIN = CASH;
constexpr PaymentMethod PaymentMethod_MAX = OFFER;
constexpr int PaymentMethod_ARRAYSIZE = PaymentMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaymentMethod_descriptor();
template<typename T>
inline const std::string& PaymentMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaymentMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaymentMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaymentMethod_descriptor(), enum_t_value);
}
inline bool PaymentMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaymentMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaymentMethod>(
    PaymentMethod_descriptor(), name, value);
}
enum PartnerPaymentType : int {
  NO_PAYMENT_TYPE = 0,
  TEAM_PAYMENT = 1,
  JOB_BASED_PAYMENT = 2,
  PartnerPaymentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PartnerPaymentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PartnerPaymentType_IsValid(int value);
constexpr PartnerPaymentType PartnerPaymentType_MIN = NO_PAYMENT_TYPE;
constexpr PartnerPaymentType PartnerPaymentType_MAX = JOB_BASED_PAYMENT;
constexpr int PartnerPaymentType_ARRAYSIZE = PartnerPaymentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartnerPaymentType_descriptor();
template<typename T>
inline const std::string& PartnerPaymentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartnerPaymentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartnerPaymentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartnerPaymentType_descriptor(), enum_t_value);
}
inline bool PartnerPaymentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PartnerPaymentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartnerPaymentType>(
    PartnerPaymentType_descriptor(), name, value);
}
enum OverlapStatus : int {
  OVERLAP_STATUS_NOT_APPLICABLE = 0,
  OVERLAP_STATUS_PENDING = 1,
  OVERLAP_DETECTED = 2,
  OVERLAP_NOT_DETECTED = 3,
  OverlapStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OverlapStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OverlapStatus_IsValid(int value);
constexpr OverlapStatus OverlapStatus_MIN = OVERLAP_STATUS_NOT_APPLICABLE;
constexpr OverlapStatus OverlapStatus_MAX = OVERLAP_NOT_DETECTED;
constexpr int OverlapStatus_ARRAYSIZE = OverlapStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OverlapStatus_descriptor();
template<typename T>
inline const std::string& OverlapStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OverlapStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OverlapStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OverlapStatus_descriptor(), enum_t_value);
}
inline bool OverlapStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OverlapStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OverlapStatus>(
    OverlapStatus_descriptor(), name, value);
}
enum LogicalOperator : int {
  NO_LOGICAL_OPERATOR = 0,
  UNION = 1,
  INTERSECTION = 2,
  LogicalOperator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogicalOperator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogicalOperator_IsValid(int value);
constexpr LogicalOperator LogicalOperator_MIN = NO_LOGICAL_OPERATOR;
constexpr LogicalOperator LogicalOperator_MAX = INTERSECTION;
constexpr int LogicalOperator_ARRAYSIZE = LogicalOperator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogicalOperator_descriptor();
template<typename T>
inline const std::string& LogicalOperator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogicalOperator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogicalOperator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogicalOperator_descriptor(), enum_t_value);
}
inline bool LogicalOperator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogicalOperator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogicalOperator>(
    LogicalOperator_descriptor(), name, value);
}
enum DeviceInstrumentationEventType : int {
  NO_DEVICE_INSTRUMENTATION_EVENT_TYPE = 0,
  CRM_SERVICE_SIGNUP = 1,
  DSR_SERVICE_SIGNUP = 2,
  AWD_SERVICE_SIGNUP = 3,
  GUJARAT_GROUNDNUT_SIGNUP = 4,
  GKM_PROGRAM_SIGNUP = 5,
  TRADE_PROGRAM_SIGNUP = 6,
  WEATHER_INSURANCE_SERVICE = 7,
  PRODUCT_CTA_SCANS = 8,
  MOS_SERVICES_BOOKING_CREATION = 9,
  SPRAY_BOOKINGS_CREATION = 10,
  ONBOARDING_REFERRAL = 11,
  KAVACH_PURCHASE = 12,
  DeviceInstrumentationEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DeviceInstrumentationEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DeviceInstrumentationEventType_IsValid(int value);
constexpr DeviceInstrumentationEventType DeviceInstrumentationEventType_MIN = NO_DEVICE_INSTRUMENTATION_EVENT_TYPE;
constexpr DeviceInstrumentationEventType DeviceInstrumentationEventType_MAX = KAVACH_PURCHASE;
constexpr int DeviceInstrumentationEventType_ARRAYSIZE = DeviceInstrumentationEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceInstrumentationEventType_descriptor();
template<typename T>
inline const std::string& DeviceInstrumentationEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceInstrumentationEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceInstrumentationEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceInstrumentationEventType_descriptor(), enum_t_value);
}
inline bool DeviceInstrumentationEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceInstrumentationEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceInstrumentationEventType>(
    DeviceInstrumentationEventType_descriptor(), name, value);
}
enum UserJourneyEventType : int {
  NO_USER_JOURNEY_EVENT_TYPE = 0,
  ACTION = 1,
  INACTION = 2,
  PAST_DATA = 3,
  CUSTOM = 4,
  UserJourneyEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UserJourneyEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UserJourneyEventType_IsValid(int value);
constexpr UserJourneyEventType UserJourneyEventType_MIN = NO_USER_JOURNEY_EVENT_TYPE;
constexpr UserJourneyEventType UserJourneyEventType_MAX = CUSTOM;
constexpr int UserJourneyEventType_ARRAYSIZE = UserJourneyEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserJourneyEventType_descriptor();
template<typename T>
inline const std::string& UserJourneyEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserJourneyEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserJourneyEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserJourneyEventType_descriptor(), enum_t_value);
}
inline bool UserJourneyEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserJourneyEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserJourneyEventType>(
    UserJourneyEventType_descriptor(), name, value);
}
enum CampaignEdgeType : int {
  NO_EDGE_TYPE = 0,
  CHECKPOINT = 1,
  EXIT = 2,
  CampaignEdgeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CampaignEdgeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CampaignEdgeType_IsValid(int value);
constexpr CampaignEdgeType CampaignEdgeType_MIN = NO_EDGE_TYPE;
constexpr CampaignEdgeType CampaignEdgeType_MAX = EXIT;
constexpr int CampaignEdgeType_ARRAYSIZE = CampaignEdgeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CampaignEdgeType_descriptor();
template<typename T>
inline const std::string& CampaignEdgeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CampaignEdgeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CampaignEdgeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CampaignEdgeType_descriptor(), enum_t_value);
}
inline bool CampaignEdgeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CampaignEdgeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CampaignEdgeType>(
    CampaignEdgeType_descriptor(), name, value);
}
enum EventPropertyType : int {
  NO_EVENT_PROPERTY_TYPE = 0,
  EVENT_PARAMETER = 1,
  EventPropertyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EventPropertyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EventPropertyType_IsValid(int value);
constexpr EventPropertyType EventPropertyType_MIN = NO_EVENT_PROPERTY_TYPE;
constexpr EventPropertyType EventPropertyType_MAX = EVENT_PARAMETER;
constexpr int EventPropertyType_ARRAYSIZE = EventPropertyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventPropertyType_descriptor();
template<typename T>
inline const std::string& EventPropertyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventPropertyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventPropertyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventPropertyType_descriptor(), enum_t_value);
}
inline bool EventPropertyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventPropertyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventPropertyType>(
    EventPropertyType_descriptor(), name, value);
}
enum PurchaseStatus : int {
  NO_PURCHASE_STATUS = 0,
  FAILED = 1,
  PENDING = 2,
  PURCHASED = 3,
  REFUNDED = 4,
  PurchaseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PurchaseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PurchaseStatus_IsValid(int value);
constexpr PurchaseStatus PurchaseStatus_MIN = NO_PURCHASE_STATUS;
constexpr PurchaseStatus PurchaseStatus_MAX = REFUNDED;
constexpr int PurchaseStatus_ARRAYSIZE = PurchaseStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PurchaseStatus_descriptor();
template<typename T>
inline const std::string& PurchaseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PurchaseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PurchaseStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PurchaseStatus_descriptor(), enum_t_value);
}
inline bool PurchaseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PurchaseStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PurchaseStatus>(
    PurchaseStatus_descriptor(), name, value);
}
enum FileType : int {
  NO_FILE_TYPE = 0,
  JPEG = 1,
  PNG = 2,
  PDF = 3,
  DOC = 4,
  FileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FileType_IsValid(int value);
constexpr FileType FileType_MIN = NO_FILE_TYPE;
constexpr FileType FileType_MAX = DOC;
constexpr int FileType_ARRAYSIZE = FileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileType_descriptor();
template<typename T>
inline const std::string& FileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileType_descriptor(), enum_t_value);
}
inline bool FileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileType>(
    FileType_descriptor(), name, value);
}
enum CropStage : int {
  NO_CROP_STAGE = 0,
  CROP_STAGE_SOWING = 1,
  CROP_STAGE_HARVESTING = 2,
  CropStage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CropStage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CropStage_IsValid(int value);
constexpr CropStage CropStage_MIN = NO_CROP_STAGE;
constexpr CropStage CropStage_MAX = CROP_STAGE_HARVESTING;
constexpr int CropStage_ARRAYSIZE = CropStage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CropStage_descriptor();
template<typename T>
inline const std::string& CropStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CropStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CropStage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CropStage_descriptor(), enum_t_value);
}
inline bool CropStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CropStage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CropStage>(
    CropStage_descriptor(), name, value);
}
enum LogicOperator : int {
  NO_VALUE = 0,
  AND = 1,
  OR = 2,
  NOT = 3,
  LogicOperator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogicOperator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogicOperator_IsValid(int value);
constexpr LogicOperator LogicOperator_MIN = NO_VALUE;
constexpr LogicOperator LogicOperator_MAX = NOT;
constexpr int LogicOperator_ARRAYSIZE = LogicOperator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogicOperator_descriptor();
template<typename T>
inline const std::string& LogicOperator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogicOperator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogicOperator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogicOperator_descriptor(), enum_t_value);
}
inline bool LogicOperator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogicOperator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogicOperator>(
    LogicOperator_descriptor(), name, value);
}
enum ImageQuality : int {
  NO_IMAGE_QUALITY = 0,
  GOOD = 1,
  POOR_THE_IMAGE_IS_BLURRY = 2,
  POOR_THE_OBJECT_IS_TOO_FAR = 3,
  POOR_THE_OBJECT_IS_TOO_CLOSE = 4,
  ImageQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImageQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImageQuality_IsValid(int value);
constexpr ImageQuality ImageQuality_MIN = NO_IMAGE_QUALITY;
constexpr ImageQuality ImageQuality_MAX = POOR_THE_OBJECT_IS_TOO_CLOSE;
constexpr int ImageQuality_ARRAYSIZE = ImageQuality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImageQuality_descriptor();
template<typename T>
inline const std::string& ImageQuality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImageQuality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImageQuality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImageQuality_descriptor(), enum_t_value);
}
inline bool ImageQuality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageQuality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImageQuality>(
    ImageQuality_descriptor(), name, value);
}
enum CropQuality : int {
  NO_CROP_QUALITY = 0,
  HEALTHY = 1,
  UNHEALTHY = 2,
  CropQuality_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CropQuality_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CropQuality_IsValid(int value);
constexpr CropQuality CropQuality_MIN = NO_CROP_QUALITY;
constexpr CropQuality CropQuality_MAX = UNHEALTHY;
constexpr int CropQuality_ARRAYSIZE = CropQuality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CropQuality_descriptor();
template<typename T>
inline const std::string& CropQuality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CropQuality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CropQuality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CropQuality_descriptor(), enum_t_value);
}
inline bool CropQuality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CropQuality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CropQuality>(
    CropQuality_descriptor(), name, value);
}
enum CropDamageType : int {
  CROP_DAMAGE_TYPE_WEED = 0,
  CROP_DAMAGE_TYPE_DISEASE = 1,
  CROP_DAMAGE_TYPE_PEST = 2,
  CROP_DAMAGE_TYPE_OTHERS = 3,
  CropDamageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CropDamageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CropDamageType_IsValid(int value);
constexpr CropDamageType CropDamageType_MIN = CROP_DAMAGE_TYPE_WEED;
constexpr CropDamageType CropDamageType_MAX = CROP_DAMAGE_TYPE_OTHERS;
constexpr int CropDamageType_ARRAYSIZE = CropDamageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CropDamageType_descriptor();
template<typename T>
inline const std::string& CropDamageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CropDamageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CropDamageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CropDamageType_descriptor(), enum_t_value);
}
inline bool CropDamageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CropDamageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CropDamageType>(
    CropDamageType_descriptor(), name, value);
}
enum PlantPart : int {
  PLANT_PART_NONE = 0,
  PLANT_PART_SEEDLING = 1,
  PLANT_PART_ROOT = 2,
  PLANT_PART_LEAF = 3,
  PLANT_PART_STEM = 4,
  PLANT_PART_BRANCH = 5,
  PLANT_PART_TILLER = 6,
  PLANT_PART_PANICLE = 7,
  PLANT_PART_FLOWER = 8,
  PLANT_PART_FRUIT = 9,
  PLANT_PART_POD = 10,
  PLANT_PART_TUBER = 11,
  PLANT_PART_BULB = 12,
  PLANT_PART_FLOWER_BUD = 13,
  PLANT_PART_COB = 14,
  PLANT_PART_TASSEL = 15,
  PLANT_PART_INFLORESCENCE = 16,
  PLANT_PART_SETTS = 17,
  PLANT_PART_BOLL = 18,
  PLANT_PART_SQUARE = 19,
  PLANT_PART_PEGS = 20,
  PLANT_PART_INTERNODES = 21,
  PLANT_PART_NODES = 22,
  PlantPart_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlantPart_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlantPart_IsValid(int value);
constexpr PlantPart PlantPart_MIN = PLANT_PART_NONE;
constexpr PlantPart PlantPart_MAX = PLANT_PART_NODES;
constexpr int PlantPart_ARRAYSIZE = PlantPart_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlantPart_descriptor();
template<typename T>
inline const std::string& PlantPart_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlantPart>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlantPart_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlantPart_descriptor(), enum_t_value);
}
inline bool PlantPart_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlantPart* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlantPart>(
    PlantPart_descriptor(), name, value);
}
enum CropLevelStage : int {
  NO_CROP_LEVEL_STAGE = 0,
  SEEDLING = 1,
  VEGETATIVE = 2,
  TILLERING = 3,
  PANICLE = 4,
  MILKING = 5,
  GRAIN_MATURITY = 6,
  GERMINATION_AND_EMERGENCE = 7,
  LEAF_AREA_AND_CANOPY_DEVELOPMENT = 8,
  FLOWERING = 9,
  BOLL_DEVELOPMENT = 10,
  BOLL_MATURATION = 11,
  STEM_ELONGATION = 12,
  BRANCHING = 13,
  FRUIT_FORMATION_AND_DEVELOPMENT = 14,
  FRUIT_MATURITY = 15,
  PEG_FORMATION = 16,
  PEG_PENETRATION = 17,
  POD_FORMATION = 18,
  POD_DEVELOPMENT = 19,
  POD_FILLING = 20,
  RIPENING = 21,
  TASSELING = 22,
  SILKING = 23,
  COB_FORMATION = 24,
  COB_DEVELOPMENT = 25,
  PHYSIOLOGICAL_MATURITY = 26,
  SPROUTING = 27,
  CropLevelStage_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CropLevelStage_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CropLevelStage_IsValid(int value);
constexpr CropLevelStage CropLevelStage_MIN = NO_CROP_LEVEL_STAGE;
constexpr CropLevelStage CropLevelStage_MAX = SPROUTING;
constexpr int CropLevelStage_ARRAYSIZE = CropLevelStage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CropLevelStage_descriptor();
template<typename T>
inline const std::string& CropLevelStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CropLevelStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CropLevelStage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CropLevelStage_descriptor(), enum_t_value);
}
inline bool CropLevelStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CropLevelStage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CropLevelStage>(
    CropLevelStage_descriptor(), name, value);
}
enum Nutrients : int {
  UNKNOWN_NUTRIENT = 0,
  PH = 1,
  OC = 2,
  EC = 3,
  N = 4,
  P = 5,
  K = 6,
  Nutrients_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Nutrients_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Nutrients_IsValid(int value);
constexpr Nutrients Nutrients_MIN = UNKNOWN_NUTRIENT;
constexpr Nutrients Nutrients_MAX = K;
constexpr int Nutrients_ARRAYSIZE = Nutrients_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Nutrients_descriptor();
template<typename T>
inline const std::string& Nutrients_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Nutrients>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Nutrients_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Nutrients_descriptor(), enum_t_value);
}
inline bool Nutrients_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Nutrients* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Nutrients>(
    Nutrients_descriptor(), name, value);
}
enum ProductType : int {
  UNKNOWN_PRODUCT_TYPE = 0,
  FERTILIZER = 1,
  ProductType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProductType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProductType_IsValid(int value);
constexpr ProductType ProductType_MIN = UNKNOWN_PRODUCT_TYPE;
constexpr ProductType ProductType_MAX = FERTILIZER;
constexpr int ProductType_ARRAYSIZE = ProductType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProductType_descriptor();
template<typename T>
inline const std::string& ProductType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProductType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProductType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProductType_descriptor(), enum_t_value);
}
inline bool ProductType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProductType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProductType>(
    ProductType_descriptor(), name, value);
}
enum ProductClass : int {
  UNKNOWN_PRODUCT_CLASS = 0,
  DAP = 1,
  UREA = 2,
  SSP = 3,
  ProductClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProductClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProductClass_IsValid(int value);
constexpr ProductClass ProductClass_MIN = UNKNOWN_PRODUCT_CLASS;
constexpr ProductClass ProductClass_MAX = SSP;
constexpr int ProductClass_ARRAYSIZE = ProductClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProductClass_descriptor();
template<typename T>
inline const std::string& ProductClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProductClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProductClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProductClass_descriptor(), enum_t_value);
}
inline bool ProductClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProductClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProductClass>(
    ProductClass_descriptor(), name, value);
}
enum States : int {
  INVALID_STATE = 0,
  States_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  States_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool States_IsValid(int value);
constexpr States States_MIN = INVALID_STATE;
constexpr States States_MAX = INVALID_STATE;
constexpr int States_ARRAYSIZE = States_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* States_descriptor();
template<typename T>
inline const std::string& States_Name(T enum_t_value) {
  static_assert(::std::is_same<T, States>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function States_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    States_descriptor(), enum_t_value);
}
inline bool States_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, States* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<States>(
    States_descriptor(), name, value);
}
enum GeofencingSource : int {
  UNKNOWN_GEOFENCE_SOURCE = 0,
  MAPS_GEOFENCE_SOURCE = 1,
  FARM_APP_GEOFENCE_SOURCE = 2,
  GeofencingSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeofencingSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeofencingSource_IsValid(int value);
constexpr GeofencingSource GeofencingSource_MIN = UNKNOWN_GEOFENCE_SOURCE;
constexpr GeofencingSource GeofencingSource_MAX = FARM_APP_GEOFENCE_SOURCE;
constexpr int GeofencingSource_ARRAYSIZE = GeofencingSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeofencingSource_descriptor();
template<typename T>
inline const std::string& GeofencingSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeofencingSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeofencingSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeofencingSource_descriptor(), enum_t_value);
}
inline bool GeofencingSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeofencingSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeofencingSource>(
    GeofencingSource_descriptor(), name, value);
}
enum FileGroupType : int {
  UNKNOWN_FILE = 0,
  SOIL_TESTING_SI_WARE_SCAN_FILE = 1,
  SOIL_TESTING_PURE_SCAN_FILE = 2,
  SOIL_HEALTH_CARD_REPORT_FILE = 3,
  FileGroupType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FileGroupType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FileGroupType_IsValid(int value);
constexpr FileGroupType FileGroupType_MIN = UNKNOWN_FILE;
constexpr FileGroupType FileGroupType_MAX = SOIL_HEALTH_CARD_REPORT_FILE;
constexpr int FileGroupType_ARRAYSIZE = FileGroupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileGroupType_descriptor();
template<typename T>
inline const std::string& FileGroupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileGroupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileGroupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileGroupType_descriptor(), enum_t_value);
}
inline bool FileGroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileGroupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileGroupType>(
    FileGroupType_descriptor(), name, value);
}
enum INVOICE_TYPE : int {
  E_INVOICE = 0,
  TAX_INVOICE = 1,
  BILL_OF_SUPPLY = 2,
  CREDIT_NOTE = 3,
  DEBIT_NOTE = 4,
  ORIGINAL_INVOICE = 5,
  INVOICE_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  INVOICE_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool INVOICE_TYPE_IsValid(int value);
constexpr INVOICE_TYPE INVOICE_TYPE_MIN = E_INVOICE;
constexpr INVOICE_TYPE INVOICE_TYPE_MAX = ORIGINAL_INVOICE;
constexpr int INVOICE_TYPE_ARRAYSIZE = INVOICE_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* INVOICE_TYPE_descriptor();
template<typename T>
inline const std::string& INVOICE_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, INVOICE_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function INVOICE_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    INVOICE_TYPE_descriptor(), enum_t_value);
}
inline bool INVOICE_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, INVOICE_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<INVOICE_TYPE>(
    INVOICE_TYPE_descriptor(), name, value);
}
enum BILLING_TYPE : int {
  ORIGINAL_BILL = 0,
  DEBIT_NOTE_BILL = 1,
  CREDIT_NOTE_BILL = 2,
  BILLING_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BILLING_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BILLING_TYPE_IsValid(int value);
constexpr BILLING_TYPE BILLING_TYPE_MIN = ORIGINAL_BILL;
constexpr BILLING_TYPE BILLING_TYPE_MAX = CREDIT_NOTE_BILL;
constexpr int BILLING_TYPE_ARRAYSIZE = BILLING_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BILLING_TYPE_descriptor();
template<typename T>
inline const std::string& BILLING_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BILLING_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BILLING_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BILLING_TYPE_descriptor(), enum_t_value);
}
inline bool BILLING_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BILLING_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BILLING_TYPE>(
    BILLING_TYPE_descriptor(), name, value);
}
enum GameRewardStatus : int {
  NO_REWARD_STATUS = 0,
  REWARD_PENDING = 1,
  REWARD_SUCCESS = 2,
  REWARD_FAILURE = 3,
  GameRewardStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GameRewardStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GameRewardStatus_IsValid(int value);
constexpr GameRewardStatus GameRewardStatus_MIN = NO_REWARD_STATUS;
constexpr GameRewardStatus GameRewardStatus_MAX = REWARD_FAILURE;
constexpr int GameRewardStatus_ARRAYSIZE = GameRewardStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameRewardStatus_descriptor();
template<typename T>
inline const std::string& GameRewardStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameRewardStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameRewardStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameRewardStatus_descriptor(), enum_t_value);
}
inline bool GameRewardStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameRewardStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameRewardStatus>(
    GameRewardStatus_descriptor(), name, value);
}
enum PageRenderViewType : int {
  UNKNOWN_PAGE_RENDER_TYPE = 0,
  JOB_TYPE_VIEW = 1,
  REFERENCE_FARMER_TYPE = 2,
  DELIVERY_PARTNER = 3,
  PageRenderViewType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PageRenderViewType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PageRenderViewType_IsValid(int value);
constexpr PageRenderViewType PageRenderViewType_MIN = UNKNOWN_PAGE_RENDER_TYPE;
constexpr PageRenderViewType PageRenderViewType_MAX = DELIVERY_PARTNER;
constexpr int PageRenderViewType_ARRAYSIZE = PageRenderViewType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PageRenderViewType_descriptor();
template<typename T>
inline const std::string& PageRenderViewType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PageRenderViewType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PageRenderViewType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PageRenderViewType_descriptor(), enum_t_value);
}
inline bool PageRenderViewType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PageRenderViewType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PageRenderViewType>(
    PageRenderViewType_descriptor(), name, value);
}
enum OfferType : int {
  CASHBACK = 0,
  DISCOUNT = 1,
  OfferType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OfferType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OfferType_IsValid(int value);
constexpr OfferType OfferType_MIN = CASHBACK;
constexpr OfferType OfferType_MAX = DISCOUNT;
constexpr int OfferType_ARRAYSIZE = OfferType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OfferType_descriptor();
template<typename T>
inline const std::string& OfferType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OfferType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OfferType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OfferType_descriptor(), enum_t_value);
}
inline bool OfferType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OfferType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OfferType>(
    OfferType_descriptor(), name, value);
}
enum OfferEventTargetAction : int {
  INVALID = 0,
  REWARDING = 1,
  COMMUNICATION = 2,
  CANCELLING = 3,
  FAILING = 4,
  OfferEventTargetAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OfferEventTargetAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OfferEventTargetAction_IsValid(int value);
constexpr OfferEventTargetAction OfferEventTargetAction_MIN = INVALID;
constexpr OfferEventTargetAction OfferEventTargetAction_MAX = FAILING;
constexpr int OfferEventTargetAction_ARRAYSIZE = OfferEventTargetAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OfferEventTargetAction_descriptor();
template<typename T>
inline const std::string& OfferEventTargetAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OfferEventTargetAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OfferEventTargetAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OfferEventTargetAction_descriptor(), enum_t_value);
}
inline bool OfferEventTargetAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OfferEventTargetAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OfferEventTargetAction>(
    OfferEventTargetAction_descriptor(), name, value);
}
enum OfferDiscountValidateKeys : int {
  SELLER_NAME = 0,
  PRODUCT_NAME = 1,
  PAYMENT_TYPE = 2,
  AMOUNT = 3,
  AMOUNT_WITHOUT_GST = 4,
  OfferDiscountValidateKeys_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OfferDiscountValidateKeys_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OfferDiscountValidateKeys_IsValid(int value);
constexpr OfferDiscountValidateKeys OfferDiscountValidateKeys_MIN = SELLER_NAME;
constexpr OfferDiscountValidateKeys OfferDiscountValidateKeys_MAX = AMOUNT_WITHOUT_GST;
constexpr int OfferDiscountValidateKeys_ARRAYSIZE = OfferDiscountValidateKeys_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OfferDiscountValidateKeys_descriptor();
template<typename T>
inline const std::string& OfferDiscountValidateKeys_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OfferDiscountValidateKeys>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OfferDiscountValidateKeys_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OfferDiscountValidateKeys_descriptor(), enum_t_value);
}
inline bool OfferDiscountValidateKeys_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OfferDiscountValidateKeys* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OfferDiscountValidateKeys>(
    OfferDiscountValidateKeys_descriptor(), name, value);
}
enum GeographySource : int {
  NO_GEOGRAPHY_SOURCE = 0,
  ACTOR_LATLONG = 1,
  ACTOR_FARM = 2,
  BOTH = 3,
  GeographySource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeographySource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeographySource_IsValid(int value);
constexpr GeographySource GeographySource_MIN = NO_GEOGRAPHY_SOURCE;
constexpr GeographySource GeographySource_MAX = BOTH;
constexpr int GeographySource_ARRAYSIZE = GeographySource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeographySource_descriptor();
template<typename T>
inline const std::string& GeographySource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeographySource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeographySource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeographySource_descriptor(), enum_t_value);
}
inline bool GeographySource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeographySource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeographySource>(
    GeographySource_descriptor(), name, value);
}
enum ModelType : int {
  NO_MODEL_TYPE = 0,
  MODEL_TYPE_NORMAL = 1,
  MODEL_TYPE_TEMPORAL = 2,
  ModelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModelType_IsValid(int value);
constexpr ModelType ModelType_MIN = NO_MODEL_TYPE;
constexpr ModelType ModelType_MAX = MODEL_TYPE_TEMPORAL;
constexpr int ModelType_ARRAYSIZE = ModelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ModelType_descriptor();
template<typename T>
inline const std::string& ModelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ModelType_descriptor(), enum_t_value);
}
inline bool ModelType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ModelType>(
    ModelType_descriptor(), name, value);
}
enum TaxType : int {
  CGST = 0,
  SGST = 1,
  IGST = 2,
  TaxType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TaxType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TaxType_IsValid(int value);
constexpr TaxType TaxType_MIN = CGST;
constexpr TaxType TaxType_MAX = IGST;
constexpr int TaxType_ARRAYSIZE = TaxType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaxType_descriptor();
template<typename T>
inline const std::string& TaxType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaxType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaxType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaxType_descriptor(), enum_t_value);
}
inline bool TaxType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaxType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaxType>(
    TaxType_descriptor(), name, value);
}
enum ScoringStratergyType : int {
  NO_SCORING_STRATERGY_TYPE = 0,
  ROLLING_WEIGHTED_SUM = 1,
  ScoringStratergyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ScoringStratergyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ScoringStratergyType_IsValid(int value);
constexpr ScoringStratergyType ScoringStratergyType_MIN = NO_SCORING_STRATERGY_TYPE;
constexpr ScoringStratergyType ScoringStratergyType_MAX = ROLLING_WEIGHTED_SUM;
constexpr int ScoringStratergyType_ARRAYSIZE = ScoringStratergyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScoringStratergyType_descriptor();
template<typename T>
inline const std::string& ScoringStratergyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScoringStratergyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScoringStratergyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScoringStratergyType_descriptor(), enum_t_value);
}
inline bool ScoringStratergyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScoringStratergyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScoringStratergyType>(
    ScoringStratergyType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace contracts
}  // namespace core
}  // namespace nurture
}  // namespace farm

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EventType>() {
  return ::farm::nurture::core::contracts::common::EventType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::BookingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::BookingType>() {
  return ::farm::nurture::core::contracts::common::BookingType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ServiceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ServiceType>() {
  return ::farm::nurture::core::contracts::common::ServiceType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::WorkType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::WorkType>() {
  return ::farm::nurture::core::contracts::common::WorkType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::WorkClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::WorkClass>() {
  return ::farm::nurture::core::contracts::common::WorkClass_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ServiceClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ServiceClass>() {
  return ::farm::nurture::core::contracts::common::ServiceClass_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::UnitType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::UnitType>() {
  return ::farm::nurture::core::contracts::common::UnitType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProductSKUClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProductSKUClass>() {
  return ::farm::nurture::core::contracts::common::ProductSKUClass_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProductSKUType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProductSKUType>() {
  return ::farm::nurture::core::contracts::common::ProductSKUType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::VisitType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::VisitType>() {
  return ::farm::nurture::core::contracts::common::VisitType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EventReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EventReason>() {
  return ::farm::nurture::core::contracts::common::EventReason_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EventUpdateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EventUpdateType>() {
  return ::farm::nurture::core::contracts::common::EventUpdateType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ActorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ActorType>() {
  return ::farm::nurture::core::contracts::common::ActorType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::BookingSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::BookingSource>() {
  return ::farm::nurture::core::contracts::common::BookingSource_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ClientType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ClientType>() {
  return ::farm::nurture::core::contracts::common::ClientType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::BookingStatusReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::BookingStatusReason>() {
  return ::farm::nurture::core::contracts::common::BookingStatusReason_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::BookingStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::BookingStatus>() {
  return ::farm::nurture::core::contracts::common::BookingStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::WorkflowStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::WorkflowStatus>() {
  return ::farm::nurture::core::contracts::common::WorkflowStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::WorkflowStatusReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::WorkflowStatusReason>() {
  return ::farm::nurture::core::contracts::common::WorkflowStatusReason_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ActorAllotmentStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ActorAllotmentStatus>() {
  return ::farm::nurture::core::contracts::common::ActorAllotmentStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ActorAllotmentStatusReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ActorAllotmentStatusReason>() {
  return ::farm::nurture::core::contracts::common::ActorAllotmentStatusReason_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProductSKUPurchaseChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProductSKUPurchaseChannel>() {
  return ::farm::nurture::core::contracts::common::ProductSKUPurchaseChannel_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProductSKUDomain> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProductSKUDomain>() {
  return ::farm::nurture::core::contracts::common::ProductSKUDomain_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProductAttachmentStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProductAttachmentStatus>() {
  return ::farm::nurture::core::contracts::common::ProductAttachmentStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::Currency> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::Currency>() {
  return ::farm::nurture::core::contracts::common::Currency_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TaskStatus>() {
  return ::farm::nurture::core::contracts::common::TaskStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::RequestStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::RequestStatus>() {
  return ::farm::nurture::core::contracts::common::RequestStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::RequestStatusReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::RequestStatusReason>() {
  return ::farm::nurture::core::contracts::common::RequestStatusReason_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EventReferenceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EventReferenceType>() {
  return ::farm::nurture::core::contracts::common::EventReferenceType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::DebugLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::DebugLevel>() {
  return ::farm::nurture::core::contracts::common::DebugLevel_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TriggerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TriggerType>() {
  return ::farm::nurture::core::contracts::common::TriggerType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TriggerSubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TriggerSubType>() {
  return ::farm::nurture::core::contracts::common::TriggerSubType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TaskType>() {
  return ::farm::nurture::core::contracts::common::TaskType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TaskSubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TaskSubType>() {
  return ::farm::nurture::core::contracts::common::TaskSubType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ActorInServiceStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ActorInServiceStatus>() {
  return ::farm::nurture::core::contracts::common::ActorInServiceStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::SKUProductInServiceStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::SKUProductInServiceStatus>() {
  return ::farm::nurture::core::contracts::common::SKUProductInServiceStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TaskOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TaskOperation>() {
  return ::farm::nurture::core::contracts::common::TaskOperation_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TimeSlotType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TimeSlotType>() {
  return ::farm::nurture::core::contracts::common::TimeSlotType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ServiceAreaNamespace> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ServiceAreaNamespace>() {
  return ::farm::nurture::core::contracts::common::ServiceAreaNamespace_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::LocationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::LocationType>() {
  return ::farm::nurture::core::contracts::common::LocationType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::BookingAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::BookingAction>() {
  return ::farm::nurture::core::contracts::common::BookingAction_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ServiceAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ServiceAction>() {
  return ::farm::nurture::core::contracts::common::ServiceAction_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CommunicationChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CommunicationChannel>() {
  return ::farm::nurture::core::contracts::common::CommunicationChannel_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CommunicationStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CommunicationStatus>() {
  return ::farm::nurture::core::contracts::common::CommunicationStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CommunicationFailureCause> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CommunicationFailureCause>() {
  return ::farm::nurture::core::contracts::common::CommunicationFailureCause_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ResponseStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ResponseStatus>() {
  return ::farm::nurture::core::contracts::common::ResponseStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ResponseStatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ResponseStatusCode>() {
  return ::farm::nurture::core::contracts::common::ResponseStatusCode_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::Status>() {
  return ::farm::nurture::core::contracts::common::Status_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::FarmCropStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::FarmCropStatus>() {
  return ::farm::nurture::core::contracts::common::FarmCropStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::MediaProvider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::MediaProvider>() {
  return ::farm::nurture::core::contracts::common::MediaProvider_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::DurationUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::DurationUnit>() {
  return ::farm::nurture::core::contracts::common::DurationUnit_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::DurationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::DurationType>() {
  return ::farm::nurture::core::contracts::common::DurationType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ScaleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ScaleType>() {
  return ::farm::nurture::core::contracts::common::ScaleType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::LanguageCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::LanguageCode>() {
  return ::farm::nurture::core::contracts::common::LanguageCode_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::RewardType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::RewardType>() {
  return ::farm::nurture::core::contracts::common::RewardType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::UserActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::UserActionType>() {
  return ::farm::nurture::core::contracts::common::UserActionType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::AppID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::AppID>() {
  return ::farm::nurture::core::contracts::common::AppID_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::AppType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::AppType>() {
  return ::farm::nurture::core::contracts::common::AppType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::HandoverType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::HandoverType>() {
  return ::farm::nurture::core::contracts::common::HandoverType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::HandoverStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::HandoverStatus>() {
  return ::farm::nurture::core::contracts::common::HandoverStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::MachineEventAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::MachineEventAction>() {
  return ::farm::nurture::core::contracts::common::MachineEventAction_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ScheduleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ScheduleType>() {
  return ::farm::nurture::core::contracts::common::ScheduleType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::UserStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::UserStatus>() {
  return ::farm::nurture::core::contracts::common::UserStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::Gender> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::Gender>() {
  return ::farm::nurture::core::contracts::common::Gender_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::AddressType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::AddressType>() {
  return ::farm::nurture::core::contracts::common::AddressType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GeographyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GeographyType>() {
  return ::farm::nurture::core::contracts::common::GeographyType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::DocumentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::DocumentType>() {
  return ::farm::nurture::core::contracts::common::DocumentType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::BookingEligibilityStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::BookingEligibilityStatus>() {
  return ::farm::nurture::core::contracts::common::BookingEligibilityStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::BookingScheduleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::BookingScheduleType>() {
  return ::farm::nurture::core::contracts::common::BookingScheduleType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::BookingNameSpace> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::BookingNameSpace>() {
  return ::farm::nurture::core::contracts::common::BookingNameSpace_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::BookingClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::BookingClass>() {
  return ::farm::nurture::core::contracts::common::BookingClass_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::Language> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::Language>() {
  return ::farm::nurture::core::contracts::common::Language_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::Country> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::Country>() {
  return ::farm::nurture::core::contracts::common::Country_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PushNotificationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PushNotificationType>() {
  return ::farm::nurture::core::contracts::common::PushNotificationType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::InfoType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::InfoType>() {
  return ::farm::nurture::core::contracts::common::InfoType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::DayDurationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::DayDurationType>() {
  return ::farm::nurture::core::contracts::common::DayDurationType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::DayOfWeek> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::DayOfWeek>() {
  return ::farm::nurture::core::contracts::common::DayOfWeek_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::WeatherForecastType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::WeatherForecastType>() {
  return ::farm::nurture::core::contracts::common::WeatherForecastType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CommunicationState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CommunicationState>() {
  return ::farm::nurture::core::contracts::common::CommunicationState_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::NutrientRating> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::NutrientRating>() {
  return ::farm::nurture::core::contracts::common::NutrientRating_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CropLandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CropLandType>() {
  return ::farm::nurture::core::contracts::common::CropLandType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::SynFertilizerReplacement> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::SynFertilizerReplacement>() {
  return ::farm::nurture::core::contracts::common::SynFertilizerReplacement_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ActivityType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ActivityType>() {
  return ::farm::nurture::core::contracts::common::ActivityType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TemplateContentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TemplateContentType>() {
  return ::farm::nurture::core::contracts::common::TemplateContentType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ResponseOrderType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ResponseOrderType>() {
  return ::farm::nurture::core::contracts::common::ResponseOrderType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::SecretType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::SecretType>() {
  return ::farm::nurture::core::contracts::common::SecretType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::FeatureName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::FeatureName>() {
  return ::farm::nurture::core::contracts::common::FeatureName_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::OfferKeyName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::OfferKeyName>() {
  return ::farm::nurture::core::contracts::common::OfferKeyName_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::OfferServiceKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::OfferServiceKey>() {
  return ::farm::nurture::core::contracts::common::OfferServiceKey_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::OfferMetaKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::OfferMetaKey>() {
  return ::farm::nurture::core::contracts::common::OfferMetaKey_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::OfferCalculationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::OfferCalculationType>() {
  return ::farm::nurture::core::contracts::common::OfferCalculationType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EngagementKeyName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EngagementKeyName>() {
  return ::farm::nurture::core::contracts::common::EngagementKeyName_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EngagementServiceUserSegmentKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EngagementServiceUserSegmentKey>() {
  return ::farm::nurture::core::contracts::common::EngagementServiceUserSegmentKey_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ContentMimeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ContentMimeType>() {
  return ::farm::nurture::core::contracts::common::ContentMimeType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::UserContentStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::UserContentStatus>() {
  return ::farm::nurture::core::contracts::common::UserContentStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::QuestionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::QuestionType>() {
  return ::farm::nurture::core::contracts::common::QuestionType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ComparisonCheckType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ComparisonCheckType>() {
  return ::farm::nurture::core::contracts::common::ComparisonCheckType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::Tenant> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::Tenant>() {
  return ::farm::nurture::core::contracts::common::Tenant_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::MediaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::MediaType>() {
  return ::farm::nurture::core::contracts::common::MediaType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::MediaAccessType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::MediaAccessType>() {
  return ::farm::nurture::core::contracts::common::MediaAccessType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::DPSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::DPSource>() {
  return ::farm::nurture::core::contracts::common::DPSource_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EventSubType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EventSubType>() {
  return ::farm::nurture::core::contracts::common::EventSubType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CultivationPractice> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CultivationPractice>() {
  return ::farm::nurture::core::contracts::common::CultivationPractice_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PracticeChangeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PracticeChangeType>() {
  return ::farm::nurture::core::contracts::common::PracticeChangeType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ApprovalStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ApprovalStatus>() {
  return ::farm::nurture::core::contracts::common::ApprovalStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ApprovalStatusReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ApprovalStatusReason>() {
  return ::farm::nurture::core::contracts::common::ApprovalStatusReason_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProgramType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProgramType>() {
  return ::farm::nurture::core::contracts::common::ProgramType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProgramCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProgramCategory>() {
  return ::farm::nurture::core::contracts::common::ProgramCategory_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProgramStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProgramStatus>() {
  return ::farm::nurture::core::contracts::common::ProgramStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EventName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EventName>() {
  return ::farm::nurture::core::contracts::common::EventName_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EventCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EventCategory>() {
  return ::farm::nurture::core::contracts::common::EventCategory_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProgramPageEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProgramPageEventType>() {
  return ::farm::nurture::core::contracts::common::ProgramPageEventType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProgramLocationConfig> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProgramLocationConfig>() {
  return ::farm::nurture::core::contracts::common::ProgramLocationConfig_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GeofencingStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GeofencingStatus>() {
  return ::farm::nurture::core::contracts::common::GeofencingStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EventStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EventStatus>() {
  return ::farm::nurture::core::contracts::common::EventStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ContactType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ContactType>() {
  return ::farm::nurture::core::contracts::common::ContactType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CampaignStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CampaignStatus>() {
  return ::farm::nurture::core::contracts::common::CampaignStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::NameSpace> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::NameSpace>() {
  return ::farm::nurture::core::contracts::common::NameSpace_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CampaignQueryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CampaignQueryType>() {
  return ::farm::nurture::core::contracts::common::CampaignQueryType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CampaignQueryMappingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CampaignQueryMappingType>() {
  return ::farm::nurture::core::contracts::common::CampaignQueryMappingType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ReferralBookingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ReferralBookingType>() {
  return ::farm::nurture::core::contracts::common::ReferralBookingType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ReferralType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ReferralType>() {
  return ::farm::nurture::core::contracts::common::ReferralType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::FormStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::FormStatus>() {
  return ::farm::nurture::core::contracts::common::FormStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EligibilityStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EligibilityStatus>() {
  return ::farm::nurture::core::contracts::common::EligibilityStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ServicesName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ServicesName>() {
  return ::farm::nurture::core::contracts::common::ServicesName_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CampaignScheduleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CampaignScheduleType>() {
  return ::farm::nurture::core::contracts::common::CampaignScheduleType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ResourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ResourceType>() {
  return ::farm::nurture::core::contracts::common::ResourceType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ResourceAccessType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ResourceAccessType>() {
  return ::farm::nurture::core::contracts::common::ResourceAccessType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ContentCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ContentCategory>() {
  return ::farm::nurture::core::contracts::common::ContentCategory_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ContentProvider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ContentProvider>() {
  return ::farm::nurture::core::contracts::common::ContentProvider_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PayoutProcessType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PayoutProcessType>() {
  return ::farm::nurture::core::contracts::common::PayoutProcessType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::JobType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::JobType>() {
  return ::farm::nurture::core::contracts::common::JobType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::JobStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::JobStatus>() {
  return ::farm::nurture::core::contracts::common::JobStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PaymentStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PaymentStatus>() {
  return ::farm::nurture::core::contracts::common::PaymentStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PaymentReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PaymentReason>() {
  return ::farm::nurture::core::contracts::common::PaymentReason_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::SchemeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::SchemeType>() {
  return ::farm::nurture::core::contracts::common::SchemeType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::SchemeWindowType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::SchemeWindowType>() {
  return ::farm::nurture::core::contracts::common::SchemeWindowType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PaymentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PaymentType>() {
  return ::farm::nurture::core::contracts::common::PaymentType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PerformanceQueryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PerformanceQueryType>() {
  return ::farm::nurture::core::contracts::common::PerformanceQueryType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PerformanceQueryMappingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PerformanceQueryMappingType>() {
  return ::farm::nurture::core::contracts::common::PerformanceQueryMappingType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PerformanceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PerformanceType>() {
  return ::farm::nurture::core::contracts::common::PerformanceType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ContentDataCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ContentDataCategory>() {
  return ::farm::nurture::core::contracts::common::ContentDataCategory_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::IOTBookingAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::IOTBookingAction>() {
  return ::farm::nurture::core::contracts::common::IOTBookingAction_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TargetUserWorkflowQueryMappingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TargetUserWorkflowQueryMappingType>() {
  return ::farm::nurture::core::contracts::common::TargetUserWorkflowQueryMappingType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::QuestionnaireType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::QuestionnaireType>() {
  return ::farm::nurture::core::contracts::common::QuestionnaireType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::SelectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::SelectType>() {
  return ::farm::nurture::core::contracts::common::SelectType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::QuestionnaireStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::QuestionnaireStatus>() {
  return ::farm::nurture::core::contracts::common::QuestionnaireStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ContentTagEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ContentTagEnum>() {
  return ::farm::nurture::core::contracts::common::ContentTagEnum_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CommunicationVendor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CommunicationVendor>() {
  return ::farm::nurture::core::contracts::common::CommunicationVendor_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PartnerUploadType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PartnerUploadType>() {
  return ::farm::nurture::core::contracts::common::PartnerUploadType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PartnerUploadStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PartnerUploadStatus>() {
  return ::farm::nurture::core::contracts::common::PartnerUploadStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PaymentMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PaymentMethod>() {
  return ::farm::nurture::core::contracts::common::PaymentMethod_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PartnerPaymentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PartnerPaymentType>() {
  return ::farm::nurture::core::contracts::common::PartnerPaymentType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::OverlapStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::OverlapStatus>() {
  return ::farm::nurture::core::contracts::common::OverlapStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::LogicalOperator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::LogicalOperator>() {
  return ::farm::nurture::core::contracts::common::LogicalOperator_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::DeviceInstrumentationEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::DeviceInstrumentationEventType>() {
  return ::farm::nurture::core::contracts::common::DeviceInstrumentationEventType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::UserJourneyEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::UserJourneyEventType>() {
  return ::farm::nurture::core::contracts::common::UserJourneyEventType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CampaignEdgeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CampaignEdgeType>() {
  return ::farm::nurture::core::contracts::common::CampaignEdgeType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::EventPropertyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::EventPropertyType>() {
  return ::farm::nurture::core::contracts::common::EventPropertyType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PurchaseStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PurchaseStatus>() {
  return ::farm::nurture::core::contracts::common::PurchaseStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::FileType>() {
  return ::farm::nurture::core::contracts::common::FileType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CropStage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CropStage>() {
  return ::farm::nurture::core::contracts::common::CropStage_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::LogicOperator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::LogicOperator>() {
  return ::farm::nurture::core::contracts::common::LogicOperator_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ImageQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ImageQuality>() {
  return ::farm::nurture::core::contracts::common::ImageQuality_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CropQuality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CropQuality>() {
  return ::farm::nurture::core::contracts::common::CropQuality_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CropDamageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CropDamageType>() {
  return ::farm::nurture::core::contracts::common::CropDamageType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PlantPart> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PlantPart>() {
  return ::farm::nurture::core::contracts::common::PlantPart_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CropLevelStage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CropLevelStage>() {
  return ::farm::nurture::core::contracts::common::CropLevelStage_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::Nutrients> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::Nutrients>() {
  return ::farm::nurture::core::contracts::common::Nutrients_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProductType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProductType>() {
  return ::farm::nurture::core::contracts::common::ProductType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProductClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProductClass>() {
  return ::farm::nurture::core::contracts::common::ProductClass_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::States> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::States>() {
  return ::farm::nurture::core::contracts::common::States_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GeofencingSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GeofencingSource>() {
  return ::farm::nurture::core::contracts::common::GeofencingSource_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::FileGroupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::FileGroupType>() {
  return ::farm::nurture::core::contracts::common::FileGroupType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::INVOICE_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::INVOICE_TYPE>() {
  return ::farm::nurture::core::contracts::common::INVOICE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::BILLING_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::BILLING_TYPE>() {
  return ::farm::nurture::core::contracts::common::BILLING_TYPE_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GameRewardStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GameRewardStatus>() {
  return ::farm::nurture::core::contracts::common::GameRewardStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PageRenderViewType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PageRenderViewType>() {
  return ::farm::nurture::core::contracts::common::PageRenderViewType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::OfferType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::OfferType>() {
  return ::farm::nurture::core::contracts::common::OfferType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::OfferEventTargetAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::OfferEventTargetAction>() {
  return ::farm::nurture::core::contracts::common::OfferEventTargetAction_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::OfferDiscountValidateKeys> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::OfferDiscountValidateKeys>() {
  return ::farm::nurture::core::contracts::common::OfferDiscountValidateKeys_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GeographySource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GeographySource>() {
  return ::farm::nurture::core::contracts::common::GeographySource_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ModelType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ModelType>() {
  return ::farm::nurture::core::contracts::common::ModelType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TaxType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TaxType>() {
  return ::farm::nurture::core::contracts::common::TaxType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ScoringStratergyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ScoringStratergyType>() {
  return ::farm::nurture::core::contracts::common::ScoringStratergyType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Common_2fenums_2eproto
