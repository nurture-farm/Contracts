// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Common/geo_enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Common_2fgeo_5fenums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Common_2fgeo_5fenums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Common_2fgeo_5fenums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Common_2fgeo_5fenums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Common_2fgeo_5fenums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace farm {
namespace nurture {
namespace core {
namespace contracts {
namespace common {

enum ProjectionType : int {
  WEB_MERCATOR = 0,
  ROBINSON = 1,
  STEREOGRAPHIC = 2,
  LAMBERT_CONFORMAL_CONIC = 3,
  TRANSVERSE_MERCATOR = 4,
  ProjectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ProjectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ProjectionType_IsValid(int value);
constexpr ProjectionType ProjectionType_MIN = WEB_MERCATOR;
constexpr ProjectionType ProjectionType_MAX = TRANSVERSE_MERCATOR;
constexpr int ProjectionType_ARRAYSIZE = ProjectionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProjectionType_descriptor();
template<typename T>
inline const std::string& ProjectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProjectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProjectionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProjectionType_descriptor(), enum_t_value);
}
inline bool ProjectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProjectionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProjectionType>(
    ProjectionType_descriptor(), name, value);
}
enum PlaceNamespace : int {
  POLITICAL_NAMESPACE = 0,
  MACHINE_NAMESPACE = 1,
  HIERARCHICAL = 2,
  FARMS = 3,
  PIPE_LOCATION = 4,
  IOT_PINGS = 5,
  SENTINEL_VH = 6,
  PlaceNamespace_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlaceNamespace_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlaceNamespace_IsValid(int value);
constexpr PlaceNamespace PlaceNamespace_MIN = POLITICAL_NAMESPACE;
constexpr PlaceNamespace PlaceNamespace_MAX = SENTINEL_VH;
constexpr int PlaceNamespace_ARRAYSIZE = PlaceNamespace_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlaceNamespace_descriptor();
template<typename T>
inline const std::string& PlaceNamespace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlaceNamespace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlaceNamespace_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlaceNamespace_descriptor(), enum_t_value);
}
inline bool PlaceNamespace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlaceNamespace* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlaceNamespace>(
    PlaceNamespace_descriptor(), name, value);
}
enum PlaceType : int {
  INVALID_PLACE_TYPE = 0,
  FARM_TYPE = 1,
  PlaceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlaceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlaceType_IsValid(int value);
constexpr PlaceType PlaceType_MIN = INVALID_PLACE_TYPE;
constexpr PlaceType PlaceType_MAX = FARM_TYPE;
constexpr int PlaceType_ARRAYSIZE = PlaceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlaceType_descriptor();
template<typename T>
inline const std::string& PlaceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlaceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlaceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlaceType_descriptor(), enum_t_value);
}
inline bool PlaceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlaceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlaceType>(
    PlaceType_descriptor(), name, value);
}
enum TemporalResolutionType : int {
  NO_TEMPORAL_RESOLUTION_TYPE = 0,
  GREGORIAN_CALENDAR = 1,
  INDIAN_CROP_CALENDAR = 2,
  TemporalResolutionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TemporalResolutionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TemporalResolutionType_IsValid(int value);
constexpr TemporalResolutionType TemporalResolutionType_MIN = NO_TEMPORAL_RESOLUTION_TYPE;
constexpr TemporalResolutionType TemporalResolutionType_MAX = INDIAN_CROP_CALENDAR;
constexpr int TemporalResolutionType_ARRAYSIZE = TemporalResolutionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TemporalResolutionType_descriptor();
template<typename T>
inline const std::string& TemporalResolutionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TemporalResolutionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TemporalResolutionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TemporalResolutionType_descriptor(), enum_t_value);
}
inline bool TemporalResolutionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TemporalResolutionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TemporalResolutionType>(
    TemporalResolutionType_descriptor(), name, value);
}
enum DataType : int {
  NO_DATA = 0,
  CROP = 100,
  BURNING_EVENT = 200,
  TILLING_EVENT = 300,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = NO_DATA;
constexpr DataType DataType_MAX = TILLING_EVENT;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
enum GeometryType : int {
  INVALID_GEOMETRY_TYPE = 0,
  MULTIPOLYGON = 1,
  POLYLINE = 2,
  POINT = 3,
  POLYGON = 4,
  GeometryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeometryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeometryType_IsValid(int value);
constexpr GeometryType GeometryType_MIN = INVALID_GEOMETRY_TYPE;
constexpr GeometryType GeometryType_MAX = POLYGON;
constexpr int GeometryType_ARRAYSIZE = GeometryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeometryType_descriptor();
template<typename T>
inline const std::string& GeometryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeometryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeometryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeometryType_descriptor(), enum_t_value);
}
inline bool GeometryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeometryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeometryType>(
    GeometryType_descriptor(), name, value);
}
enum DataPropertyType : int {
  NO_TYPE = 0,
  CROP_YIELD = 100,
  CROP_NAME = 101,
  CROP_TYPE = 102,
  DataPropertyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataPropertyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataPropertyType_IsValid(int value);
constexpr DataPropertyType DataPropertyType_MIN = NO_TYPE;
constexpr DataPropertyType DataPropertyType_MAX = CROP_TYPE;
constexpr int DataPropertyType_ARRAYSIZE = DataPropertyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataPropertyType_descriptor();
template<typename T>
inline const std::string& DataPropertyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataPropertyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataPropertyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataPropertyType_descriptor(), enum_t_value);
}
inline bool DataPropertyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataPropertyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataPropertyType>(
    DataPropertyType_descriptor(), name, value);
}
enum TemporalResolutionLevel : int {
  NO_TEMP_RESOLUTION_LEVEL = 0,
  TemporalResolutionLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TemporalResolutionLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TemporalResolutionLevel_IsValid(int value);
constexpr TemporalResolutionLevel TemporalResolutionLevel_MIN = NO_TEMP_RESOLUTION_LEVEL;
constexpr TemporalResolutionLevel TemporalResolutionLevel_MAX = NO_TEMP_RESOLUTION_LEVEL;
constexpr int TemporalResolutionLevel_ARRAYSIZE = TemporalResolutionLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TemporalResolutionLevel_descriptor();
template<typename T>
inline const std::string& TemporalResolutionLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TemporalResolutionLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TemporalResolutionLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TemporalResolutionLevel_descriptor(), enum_t_value);
}
inline bool TemporalResolutionLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TemporalResolutionLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TemporalResolutionLevel>(
    TemporalResolutionLevel_descriptor(), name, value);
}
enum DataPropCategoryType : int {
  NO_DATA_PROP_CATEGORY_TYPE = 0,
  DataPropCategoryType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DataPropCategoryType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DataPropCategoryType_IsValid(int value);
constexpr DataPropCategoryType DataPropCategoryType_MIN = NO_DATA_PROP_CATEGORY_TYPE;
constexpr DataPropCategoryType DataPropCategoryType_MAX = NO_DATA_PROP_CATEGORY_TYPE;
constexpr int DataPropCategoryType_ARRAYSIZE = DataPropCategoryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataPropCategoryType_descriptor();
template<typename T>
inline const std::string& DataPropCategoryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataPropCategoryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataPropCategoryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataPropCategoryType_descriptor(), enum_t_value);
}
inline bool DataPropCategoryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataPropCategoryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataPropCategoryType>(
    DataPropCategoryType_descriptor(), name, value);
}
enum GeoStatusResult : int {
  GEO_STATUS_SUCCESS = 0,
  NO_GEOMETRY_FOUND = 1,
  NO_PIPE_FOUND = 2,
  GeoStatusResult_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeoStatusResult_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeoStatusResult_IsValid(int value);
constexpr GeoStatusResult GeoStatusResult_MIN = GEO_STATUS_SUCCESS;
constexpr GeoStatusResult GeoStatusResult_MAX = NO_PIPE_FOUND;
constexpr int GeoStatusResult_ARRAYSIZE = GeoStatusResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeoStatusResult_descriptor();
template<typename T>
inline const std::string& GeoStatusResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeoStatusResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeoStatusResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeoStatusResult_descriptor(), enum_t_value);
}
inline bool GeoStatusResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeoStatusResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeoStatusResult>(
    GeoStatusResult_descriptor(), name, value);
}
enum UI_CLIENT : int {
  NO_UI_CLIENT = 0,
  DESKTOP_WEB_UI_CLIENT = 1,
  ANDROID_TAB_WEB_UI_CLIENT = 2,
  ANDROID_WEB_UI_CLIENT = 3,
  IOS_WEB_UI_CLIENT = 4,
  IOS_TAB_WEB_UI_CLIENT = 5,
  UI_CLIENT_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UI_CLIENT_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UI_CLIENT_IsValid(int value);
constexpr UI_CLIENT UI_CLIENT_MIN = NO_UI_CLIENT;
constexpr UI_CLIENT UI_CLIENT_MAX = IOS_TAB_WEB_UI_CLIENT;
constexpr int UI_CLIENT_ARRAYSIZE = UI_CLIENT_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UI_CLIENT_descriptor();
template<typename T>
inline const std::string& UI_CLIENT_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UI_CLIENT>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UI_CLIENT_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UI_CLIENT_descriptor(), enum_t_value);
}
inline bool UI_CLIENT_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UI_CLIENT* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UI_CLIENT>(
    UI_CLIENT_descriptor(), name, value);
}
enum PlaceSourceType : int {
  NO_SOURCE_TYPE = 0,
  SATELLITE_FARM = 1,
  IOT_FARM = 2,
  POLITICAL_FARM = 3,
  USER_FARM = 4,
  AWD_SOUTH_2021 = 5,
  PIPE_INSTALLATION_SRC = 6,
  INSIDE_BUND_SRC = 7,
  AERATION_EVENT_1_SRC = 8,
  AERATION_EVENT_2_SRC = 9,
  AERATION_EVENT_3_SRC = 10,
  USER_FARM_AWD = 11,
  USER_FARM_SBB = 12,
  IOT_GATEWAY_TYPE = 13,
  AERATION_1 = 14,
  AERATION_2 = 15,
  AERATION_3 = 16,
  SENTINEL_1_L2A = 17,
  PlaceSourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlaceSourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlaceSourceType_IsValid(int value);
constexpr PlaceSourceType PlaceSourceType_MIN = NO_SOURCE_TYPE;
constexpr PlaceSourceType PlaceSourceType_MAX = SENTINEL_1_L2A;
constexpr int PlaceSourceType_ARRAYSIZE = PlaceSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlaceSourceType_descriptor();
template<typename T>
inline const std::string& PlaceSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlaceSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlaceSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlaceSourceType_descriptor(), enum_t_value);
}
inline bool PlaceSourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlaceSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlaceSourceType>(
    PlaceSourceType_descriptor(), name, value);
}
enum PlaceVisibleType : int {
  NO_VISIBLE_TYPE = 0,
  VILLAGE_FARM = 1,
  DISTRICT_FARM = 2,
  PIPE = 3,
  PUSA_SPRAY_PROGRAM_TYPE = 4,
  AWD_PROGRAM_TYPE = 5,
  DSR_PROGRAM_TYPE = 6,
  GROUNDNUT_PROGRAM_TYPE = 7,
  CRM_PROGRAM_TYPE = 8,
  TRADE_PROGRAM_TYPE = 9,
  AWD_22_KHARIF_PROGRAM_TYPE = 10,
  CRM_22_KHARIF_PROGRAM_TYPE = 11,
  DSR_22_KHARIF_PROGRAM_TYPE = 12,
  POINT_TYPE = 13,
  PRUNED_POINT_TYPE = 14,
  POLYGON_TYPE = 15,
  PlaceVisibleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlaceVisibleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlaceVisibleType_IsValid(int value);
constexpr PlaceVisibleType PlaceVisibleType_MIN = NO_VISIBLE_TYPE;
constexpr PlaceVisibleType PlaceVisibleType_MAX = POLYGON_TYPE;
constexpr int PlaceVisibleType_ARRAYSIZE = PlaceVisibleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlaceVisibleType_descriptor();
template<typename T>
inline const std::string& PlaceVisibleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlaceVisibleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlaceVisibleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlaceVisibleType_descriptor(), enum_t_value);
}
inline bool PlaceVisibleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlaceVisibleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlaceVisibleType>(
    PlaceVisibleType_descriptor(), name, value);
}
enum PlaceTagProperty : int {
  NO_PLACE_TAG_PROPERTY = 0,
  NAME = 1,
  TITLE = 2,
  COLOR = 3,
  COUNT = 4,
  ACRES = 5,
  EVENT_ID = 6,
  FARMER_NAME = 7,
  FARMER_MOBILE = 8,
  REGION_NAME = 9,
  TEHSIL_NAME = 11,
  VILLAGE_NAME = 12,
  SOWING_DATE = 13,
  VARIETY = 14,
  S3_MOBILE = 15,
  S3_NAME = 16,
  APPROVAL_STATUS = 17,
  STATUS = 18,
  FARM_ID = 19,
  FARMER_ID = 20,
  PLACE_ID = 21,
  CONTENT_ID = 22,
  UGDN = 23,
  GEOFENCE_SOURCE = 24,
  SPRAYER_STATUS = 25,
  ENGINE_STATUS = 26,
  KHARIF_2022_STATUS = 27,
  RABI_2022_STATUS = 28,
  RABI_2022_PLACE_ID = 29,
  RABI_2022_PLACE_NS = 30,
  RABI_2022_PLACE_SRC = 31,
  RABI_2022_PLACE_VIS = 32,
  PORTAL_EDIT = 33,
  KHARIF_22_PORTAL_EDIT = 34,
  RABI_22_PORTAL_EDIT = 35,
  AWD_RABI_22_NSV_PLACE_ID = 36,
  PlaceTagProperty_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlaceTagProperty_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlaceTagProperty_IsValid(int value);
constexpr PlaceTagProperty PlaceTagProperty_MIN = NO_PLACE_TAG_PROPERTY;
constexpr PlaceTagProperty PlaceTagProperty_MAX = AWD_RABI_22_NSV_PLACE_ID;
constexpr int PlaceTagProperty_ARRAYSIZE = PlaceTagProperty_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlaceTagProperty_descriptor();
template<typename T>
inline const std::string& PlaceTagProperty_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlaceTagProperty>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlaceTagProperty_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlaceTagProperty_descriptor(), enum_t_value);
}
inline bool PlaceTagProperty_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlaceTagProperty* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlaceTagProperty>(
    PlaceTagProperty_descriptor(), name, value);
}
enum PlaceTagName : int {
  NO_PLACE_TAG = 0,
  FARM_NAME = 1,
  POPULATION = 2,
  DISTRICT_NAME = 4,
  AWD_PIPE = 5,
  AWD_AERATION = 6,
  AWD_BUND = 7,
  Actor = 8,
  TagName_FARMER = 9,
  PROGRAM = 10,
  TagName_FARM = 11,
  PARENT = 12,
  TagName_APPROVAL_STATUS = 13,
  CONTENT_METADATA = 14,
  REFERRAL = 15,
  GEOFENCE = 16,
  PINGS = 17,
  LOCKS = 18,
  PlaceTagName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlaceTagName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlaceTagName_IsValid(int value);
constexpr PlaceTagName PlaceTagName_MIN = NO_PLACE_TAG;
constexpr PlaceTagName PlaceTagName_MAX = LOCKS;
constexpr int PlaceTagName_ARRAYSIZE = PlaceTagName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlaceTagName_descriptor();
template<typename T>
inline const std::string& PlaceTagName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlaceTagName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlaceTagName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlaceTagName_descriptor(), enum_t_value);
}
inline bool PlaceTagName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlaceTagName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlaceTagName>(
    PlaceTagName_descriptor(), name, value);
}
enum GeometryRepresentationType : int {
  WKB = 0,
  WKT = 1,
  GEO_JSON = 2,
  GeometryRepresentationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeometryRepresentationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeometryRepresentationType_IsValid(int value);
constexpr GeometryRepresentationType GeometryRepresentationType_MIN = WKB;
constexpr GeometryRepresentationType GeometryRepresentationType_MAX = GEO_JSON;
constexpr int GeometryRepresentationType_ARRAYSIZE = GeometryRepresentationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeometryRepresentationType_descriptor();
template<typename T>
inline const std::string& GeometryRepresentationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeometryRepresentationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeometryRepresentationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeometryRepresentationType_descriptor(), enum_t_value);
}
inline bool GeometryRepresentationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeometryRepresentationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeometryRepresentationType>(
    GeometryRepresentationType_descriptor(), name, value);
}
enum ValidationResponseCode : int {
  NO_CODE = 0,
  TOO_CLOSE_TO_ANOTHER_PIPE_PICTURE_CODE = 4001,
  TOO_CLOSE_TO_ANOTHER_BUND_PICTURE_CODE = 4002,
  TOO_CLOSE_TO_ANOTHER_AERATION_PICTURE_CODE = 4003,
  PICTURE_LOCATION_LIES_INSIDE_ANOTHER_FENCE_CODE = 4004,
  PICTURE_LOCATION_NOT_LIES_INSIDE_ANY_FENCE_CODE = 4005,
  PICTURE_TOO_FAR_FROM_GEOFENCE_CODE = 4006,
  NO_PIPE_INSTALLED_CODE = 4007,
  POINT_OUTSIDE_POLYGON_CODE = 4008,
  MORE_POINT_INSIDE_POLYGON_CODE = 4009,
  POINT_INSIDE_POLYGON_CODE = 4010,
  ValidationResponseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ValidationResponseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ValidationResponseCode_IsValid(int value);
constexpr ValidationResponseCode ValidationResponseCode_MIN = NO_CODE;
constexpr ValidationResponseCode ValidationResponseCode_MAX = POINT_INSIDE_POLYGON_CODE;
constexpr int ValidationResponseCode_ARRAYSIZE = ValidationResponseCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValidationResponseCode_descriptor();
template<typename T>
inline const std::string& ValidationResponseCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValidationResponseCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValidationResponseCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValidationResponseCode_descriptor(), enum_t_value);
}
inline bool ValidationResponseCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValidationResponseCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValidationResponseCode>(
    ValidationResponseCode_descriptor(), name, value);
}
enum ValidationResponseMsg : int {
  NO_MESSAGE = 0,
  TOO_CLOSE_TO_ANOTHER_PIPE_PICTURE_MSG = 1,
  TOO_CLOSE_TO_ANOTHER_BUND_PICTURE_MSG = 2,
  TOO_CLOSE_TO_ANOTHER_AERATION_PICTURE_MSG = 3,
  PICTURE_LOCATION_LIES_INSIDE_ANOTHER_FENCE_MSG = 4,
  PICTURE_LOCATION_NOT_LIES_INSIDE_ANY_FENCE_MSG = 5,
  PICTURE_TOO_FAR_FROM_FENCE_MSG = 6,
  NO_PIPE_INSTALLED_MSG = 7,
  POINT_OUTSIDE_POLYGON_MSG = 8,
  MORE_POINT_INSIDE_POLYGON_MSG = 9,
  POINT_INSIDE_POLYGON_MSG = 10,
  ValidationResponseMsg_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ValidationResponseMsg_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ValidationResponseMsg_IsValid(int value);
constexpr ValidationResponseMsg ValidationResponseMsg_MIN = NO_MESSAGE;
constexpr ValidationResponseMsg ValidationResponseMsg_MAX = POINT_INSIDE_POLYGON_MSG;
constexpr int ValidationResponseMsg_ARRAYSIZE = ValidationResponseMsg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValidationResponseMsg_descriptor();
template<typename T>
inline const std::string& ValidationResponseMsg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValidationResponseMsg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValidationResponseMsg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValidationResponseMsg_descriptor(), enum_t_value);
}
inline bool ValidationResponseMsg_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValidationResponseMsg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValidationResponseMsg>(
    ValidationResponseMsg_descriptor(), name, value);
}
enum GeoResponseStatus : int {
  NO_RESPONSE = 0,
  FAILED_TO_VALIDATE = 1,
  FAILED_TO_INSERT = 2,
  GeoResponseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeoResponseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeoResponseStatus_IsValid(int value);
constexpr GeoResponseStatus GeoResponseStatus_MIN = NO_RESPONSE;
constexpr GeoResponseStatus GeoResponseStatus_MAX = FAILED_TO_INSERT;
constexpr int GeoResponseStatus_ARRAYSIZE = GeoResponseStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeoResponseStatus_descriptor();
template<typename T>
inline const std::string& GeoResponseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeoResponseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeoResponseStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeoResponseStatus_descriptor(), enum_t_value);
}
inline bool GeoResponseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeoResponseStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeoResponseStatus>(
    GeoResponseStatus_descriptor(), name, value);
}
enum GeoValidationType : int {
  NO_GEO_VALIDATION_TYPE = 0,
  POINT_PROXIMITY_VALIDATION = 1,
  GEOMETRY_INSIDE_GEOMETRY_VALIDATION = 2,
  GEOMETRY_OVERLAP_VALIDATION = 3,
  GEOMETRY_EXISTENCE_VALIDATION = 4,
  GeoValidationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeoValidationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeoValidationType_IsValid(int value);
constexpr GeoValidationType GeoValidationType_MIN = NO_GEO_VALIDATION_TYPE;
constexpr GeoValidationType GeoValidationType_MAX = GEOMETRY_EXISTENCE_VALIDATION;
constexpr int GeoValidationType_ARRAYSIZE = GeoValidationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeoValidationType_descriptor();
template<typename T>
inline const std::string& GeoValidationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeoValidationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeoValidationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeoValidationType_descriptor(), enum_t_value);
}
inline bool GeoValidationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeoValidationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeoValidationType>(
    GeoValidationType_descriptor(), name, value);
}
enum GeoValidationName : int {
  NO_GEO_VALIDATION_NAME = 0,
  POINT_X_WITHIN_K_METRES_FROM_POINT_Y = 1,
  POINT_X_LEAST_K_METRES_FROM_POINT_Y = 2,
  POINT_X_WITHIN_K_METRES_FROM_POLYGON_Y = 3,
  POINT_X_LEAST_K_METRES_FROM_POLYGON_Y = 4,
  POINT_X_ALONE_LIES_INSIDE_POLYGON_Y = 5,
  POLYGON_X_INSIDE_POLYGON_Y = 6,
  POINT_X_INSIDE_ANY_TARGET_SET_OF_POLYGONS = 7,
  POLYGON_X_INSIDE_ANY_TARGET_SET_OF_POLYGONS = 8,
  GEOMETRY_X_OVERLAPS_GEOMETRY_Y = 9,
  GEOMETRY_X_OVERLAPS_ANY_TARGET_SET_OF_GEOMETRIES = 10,
  GEOMETRY_X_EXISTS_IN_RESPECTIVE_DATASET = 11,
  GeoValidationName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeoValidationName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeoValidationName_IsValid(int value);
constexpr GeoValidationName GeoValidationName_MIN = NO_GEO_VALIDATION_NAME;
constexpr GeoValidationName GeoValidationName_MAX = GEOMETRY_X_EXISTS_IN_RESPECTIVE_DATASET;
constexpr int GeoValidationName_ARRAYSIZE = GeoValidationName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeoValidationName_descriptor();
template<typename T>
inline const std::string& GeoValidationName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeoValidationName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeoValidationName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeoValidationName_descriptor(), enum_t_value);
}
inline bool GeoValidationName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeoValidationName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeoValidationName>(
    GeoValidationName_descriptor(), name, value);
}
enum AssertionType : int {
  DEFAULT_ASSERTION_TYPE = 0,
  ASSERT_TRUE = 1,
  ASSERT_FALSE = 2,
  ASSERT_EQUALS = 3,
  AssertionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AssertionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AssertionType_IsValid(int value);
constexpr AssertionType AssertionType_MIN = DEFAULT_ASSERTION_TYPE;
constexpr AssertionType AssertionType_MAX = ASSERT_EQUALS;
constexpr int AssertionType_ARRAYSIZE = AssertionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AssertionType_descriptor();
template<typename T>
inline const std::string& AssertionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AssertionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AssertionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AssertionType_descriptor(), enum_t_value);
}
inline bool AssertionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AssertionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AssertionType>(
    AssertionType_descriptor(), name, value);
}
enum GeoDataSource : int {
  NO_FARM_TYPE = 0,
  USER_FARM_DATA = 1,
  USER_POINT_DATA = 2,
  GeoDataSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeoDataSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeoDataSource_IsValid(int value);
constexpr GeoDataSource GeoDataSource_MIN = NO_FARM_TYPE;
constexpr GeoDataSource GeoDataSource_MAX = USER_POINT_DATA;
constexpr int GeoDataSource_ARRAYSIZE = GeoDataSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GeoDataSource_descriptor();
template<typename T>
inline const std::string& GeoDataSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeoDataSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeoDataSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GeoDataSource_descriptor(), enum_t_value);
}
inline bool GeoDataSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GeoDataSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GeoDataSource>(
    GeoDataSource_descriptor(), name, value);
}
enum FilterKey : int {
  NO_KEY = 0,
  TAG_ID = 1,
  PLACE_Id = 2,
  TAG_NAME = 3,
  TAG_KEY = 4,
  TAG_VALUE = 5,
  TILE_KEY = 6,
  REFERENCE_TYPE = 7,
  ATTRIBUTE = 8,
  ATTRIBUTE_KEY = 9,
  FilterKey_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FilterKey_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FilterKey_IsValid(int value);
constexpr FilterKey FilterKey_MIN = NO_KEY;
constexpr FilterKey FilterKey_MAX = ATTRIBUTE_KEY;
constexpr int FilterKey_ARRAYSIZE = FilterKey_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterKey_descriptor();
template<typename T>
inline const std::string& FilterKey_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilterKey>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilterKey_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FilterKey_descriptor(), enum_t_value);
}
inline bool FilterKey_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterKey* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FilterKey>(
    FilterKey_descriptor(), name, value);
}
enum ReferenceType : int {
  NO_ENTITY_TYPE = 0,
  DEVICE_REF_TYPE = 1,
  MACHINE_REF_TYPE = 2,
  USER = 3,
  FARM_REF_TYPE = 4,
  OPERATOR_REF_TYPE = 5,
  PARENT_REF_TYPE = 6,
  ReferenceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ReferenceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ReferenceType_IsValid(int value);
constexpr ReferenceType ReferenceType_MIN = NO_ENTITY_TYPE;
constexpr ReferenceType ReferenceType_MAX = PARENT_REF_TYPE;
constexpr int ReferenceType_ARRAYSIZE = ReferenceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReferenceType_descriptor();
template<typename T>
inline const std::string& ReferenceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReferenceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReferenceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReferenceType_descriptor(), enum_t_value);
}
inline bool ReferenceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReferenceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReferenceType>(
    ReferenceType_descriptor(), name, value);
}
enum AttributeKey : int {
  NO_ATTRIBUTE_KEY = 0,
  ID = 1,
  ATT_NAME = 2,
  SERIAL_NO = 3,
  MACHINE_ID = 4,
  DEVICE_ID = 5,
  ACRE_SPRAYED = 6,
  ADDRESS = 7,
  FARM_ID_ATTRIBUTE_KEY = 8,
  FUEL_TYPE = 9,
  LAND_ACRES = 10,
  MACHINE_NUMBER = 11,
  PHONE_NO = 12,
  RABI_22_CONTENT_ID_ATT = 13,
  KHARIF_22_CONTENT_ID_ATT = 14,
  AttributeKey_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AttributeKey_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AttributeKey_IsValid(int value);
constexpr AttributeKey AttributeKey_MIN = NO_ATTRIBUTE_KEY;
constexpr AttributeKey AttributeKey_MAX = KHARIF_22_CONTENT_ID_ATT;
constexpr int AttributeKey_ARRAYSIZE = AttributeKey_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AttributeKey_descriptor();
template<typename T>
inline const std::string& AttributeKey_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AttributeKey>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AttributeKey_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AttributeKey_descriptor(), enum_t_value);
}
inline bool AttributeKey_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AttributeKey* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AttributeKey>(
    AttributeKey_descriptor(), name, value);
}
enum ServiceName : int {
  NO_SERVICE_NAME = 0,
  MAPS_VECTOR_STORE = 1,
  MAPS_PLACES_STORE = 2,
  MAPS_RASTER_INDEX = 3,
  ServiceName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ServiceName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ServiceName_IsValid(int value);
constexpr ServiceName ServiceName_MIN = NO_SERVICE_NAME;
constexpr ServiceName ServiceName_MAX = MAPS_RASTER_INDEX;
constexpr int ServiceName_ARRAYSIZE = ServiceName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceName_descriptor();
template<typename T>
inline const std::string& ServiceName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServiceName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServiceName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServiceName_descriptor(), enum_t_value);
}
inline bool ServiceName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServiceName>(
    ServiceName_descriptor(), name, value);
}
enum ValueType : int {
  NO_VALUE_TYPE = 0,
  VALUE_TYPE_DOUBLE = 1,
  VALUE_TYPE_STRING = 2,
  VALUE_TYPE_BOOLEAN = 3,
  VALUE_TYPE_INT64 = 4,
  VALUE_TYPE_INT32 = 5,
  VALUE_TYPE_NSV_PLACE_ID = 6,
  ValueType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ValueType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ValueType_IsValid(int value);
constexpr ValueType ValueType_MIN = NO_VALUE_TYPE;
constexpr ValueType ValueType_MAX = VALUE_TYPE_NSV_PLACE_ID;
constexpr int ValueType_ARRAYSIZE = ValueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValueType_descriptor();
template<typename T>
inline const std::string& ValueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValueType_descriptor(), enum_t_value);
}
inline bool ValueType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValueType>(
    ValueType_descriptor(), name, value);
}
enum ValidationName : int {
  NO_VALIDATION = 0,
  AERATION_EVENT_VALIDATION = 1,
  PIPE_INSTALLATION_VALIDATION = 2,
  INSIDE_BUND_VALIDATION = 3,
  INSIDE_GEOFENCE_VALIDATION = 4,
  ValidationName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ValidationName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ValidationName_IsValid(int value);
constexpr ValidationName ValidationName_MIN = NO_VALIDATION;
constexpr ValidationName ValidationName_MAX = INSIDE_GEOFENCE_VALIDATION;
constexpr int ValidationName_ARRAYSIZE = ValidationName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValidationName_descriptor();
template<typename T>
inline const std::string& ValidationName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValidationName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValidationName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValidationName_descriptor(), enum_t_value);
}
inline bool ValidationName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValidationName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValidationName>(
    ValidationName_descriptor(), name, value);
}
enum ValidationType : int {
  NO_VALIDATION_TYPE = 0,
  VALIDATION_TYPE_DSR = 1,
  VALIDATION_TYPE_AWD = 2,
  ValidationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ValidationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ValidationType_IsValid(int value);
constexpr ValidationType ValidationType_MIN = NO_VALIDATION_TYPE;
constexpr ValidationType ValidationType_MAX = VALIDATION_TYPE_AWD;
constexpr int ValidationType_ARRAYSIZE = ValidationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ValidationType_descriptor();
template<typename T>
inline const std::string& ValidationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ValidationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ValidationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ValidationType_descriptor(), enum_t_value);
}
inline bool ValidationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValidationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ValidationType>(
    ValidationType_descriptor(), name, value);
}
enum HealthParameters : int {
  SYSTEM_HEALTH = 0,
  DB_HEALTH = 1,
  CACHE_HEALTH = 2,
  UPSTREAM_HEALTH = 3,
  HealthParameters_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HealthParameters_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HealthParameters_IsValid(int value);
constexpr HealthParameters HealthParameters_MIN = SYSTEM_HEALTH;
constexpr HealthParameters HealthParameters_MAX = UPSTREAM_HEALTH;
constexpr int HealthParameters_ARRAYSIZE = HealthParameters_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HealthParameters_descriptor();
template<typename T>
inline const std::string& HealthParameters_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HealthParameters>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HealthParameters_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HealthParameters_descriptor(), enum_t_value);
}
inline bool HealthParameters_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HealthParameters* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HealthParameters>(
    HealthParameters_descriptor(), name, value);
}
enum CloudStore : int {
  NO_Cloud_Store = 0,
  S3_Cloud_Store = 1,
  Cloud_Front_Cloud_Store = 2,
  CloudStore_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CloudStore_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CloudStore_IsValid(int value);
constexpr CloudStore CloudStore_MIN = NO_Cloud_Store;
constexpr CloudStore CloudStore_MAX = Cloud_Front_Cloud_Store;
constexpr int CloudStore_ARRAYSIZE = CloudStore_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CloudStore_descriptor();
template<typename T>
inline const std::string& CloudStore_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CloudStore>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CloudStore_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CloudStore_descriptor(), enum_t_value);
}
inline bool CloudStore_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CloudStore* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CloudStore>(
    CloudStore_descriptor(), name, value);
}
enum UrlBuilder : int {
  NO_URL_BUILDER = 0,
  URL_BUILDER_1 = 1,
  UrlBuilder_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UrlBuilder_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UrlBuilder_IsValid(int value);
constexpr UrlBuilder UrlBuilder_MIN = NO_URL_BUILDER;
constexpr UrlBuilder UrlBuilder_MAX = URL_BUILDER_1;
constexpr int UrlBuilder_ARRAYSIZE = UrlBuilder_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UrlBuilder_descriptor();
template<typename T>
inline const std::string& UrlBuilder_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UrlBuilder>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UrlBuilder_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UrlBuilder_descriptor(), enum_t_value);
}
inline bool UrlBuilder_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UrlBuilder* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UrlBuilder>(
    UrlBuilder_descriptor(), name, value);
}
enum Satellite : int {
  NO_SATELLITE = 0,
  SATELLITE_S1 = 1,
  Satellite_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Satellite_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Satellite_IsValid(int value);
constexpr Satellite Satellite_MIN = NO_SATELLITE;
constexpr Satellite Satellite_MAX = SATELLITE_S1;
constexpr int Satellite_ARRAYSIZE = Satellite_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Satellite_descriptor();
template<typename T>
inline const std::string& Satellite_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Satellite>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Satellite_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Satellite_descriptor(), enum_t_value);
}
inline bool Satellite_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Satellite* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Satellite>(
    Satellite_descriptor(), name, value);
}
enum Band : int {
  NO_BAND = 0,
  BAND_VH = 1,
  BAND_VV = 2,
  Band_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Band_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Band_IsValid(int value);
constexpr Band Band_MIN = NO_BAND;
constexpr Band Band_MAX = BAND_VV;
constexpr int Band_ARRAYSIZE = Band_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Band_descriptor();
template<typename T>
inline const std::string& Band_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Band>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Band_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Band_descriptor(), enum_t_value);
}
inline bool Band_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Band* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Band>(
    Band_descriptor(), name, value);
}
enum AppName : int {
  NO_APP_NAME = 0,
  APP_NAME_AWD = 1,
  APP_NAME_CRM = 2,
  APP_NAME_DSR = 3,
  AppName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AppName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AppName_IsValid(int value);
constexpr AppName AppName_MIN = NO_APP_NAME;
constexpr AppName AppName_MAX = APP_NAME_DSR;
constexpr int AppName_ARRAYSIZE = AppName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppName_descriptor();
template<typename T>
inline const std::string& AppName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppName_descriptor(), enum_t_value);
}
inline bool AppName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppName>(
    AppName_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace contracts
}  // namespace core
}  // namespace nurture
}  // namespace farm

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ProjectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ProjectionType>() {
  return ::farm::nurture::core::contracts::common::ProjectionType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PlaceNamespace> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PlaceNamespace>() {
  return ::farm::nurture::core::contracts::common::PlaceNamespace_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PlaceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PlaceType>() {
  return ::farm::nurture::core::contracts::common::PlaceType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TemporalResolutionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TemporalResolutionType>() {
  return ::farm::nurture::core::contracts::common::TemporalResolutionType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::DataType>() {
  return ::farm::nurture::core::contracts::common::DataType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GeometryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GeometryType>() {
  return ::farm::nurture::core::contracts::common::GeometryType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::DataPropertyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::DataPropertyType>() {
  return ::farm::nurture::core::contracts::common::DataPropertyType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::TemporalResolutionLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::TemporalResolutionLevel>() {
  return ::farm::nurture::core::contracts::common::TemporalResolutionLevel_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::DataPropCategoryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::DataPropCategoryType>() {
  return ::farm::nurture::core::contracts::common::DataPropCategoryType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GeoStatusResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GeoStatusResult>() {
  return ::farm::nurture::core::contracts::common::GeoStatusResult_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::UI_CLIENT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::UI_CLIENT>() {
  return ::farm::nurture::core::contracts::common::UI_CLIENT_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PlaceSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PlaceSourceType>() {
  return ::farm::nurture::core::contracts::common::PlaceSourceType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PlaceVisibleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PlaceVisibleType>() {
  return ::farm::nurture::core::contracts::common::PlaceVisibleType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PlaceTagProperty> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PlaceTagProperty>() {
  return ::farm::nurture::core::contracts::common::PlaceTagProperty_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::PlaceTagName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::PlaceTagName>() {
  return ::farm::nurture::core::contracts::common::PlaceTagName_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GeometryRepresentationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GeometryRepresentationType>() {
  return ::farm::nurture::core::contracts::common::GeometryRepresentationType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ValidationResponseCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ValidationResponseCode>() {
  return ::farm::nurture::core::contracts::common::ValidationResponseCode_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ValidationResponseMsg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ValidationResponseMsg>() {
  return ::farm::nurture::core::contracts::common::ValidationResponseMsg_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GeoResponseStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GeoResponseStatus>() {
  return ::farm::nurture::core::contracts::common::GeoResponseStatus_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GeoValidationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GeoValidationType>() {
  return ::farm::nurture::core::contracts::common::GeoValidationType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GeoValidationName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GeoValidationName>() {
  return ::farm::nurture::core::contracts::common::GeoValidationName_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::AssertionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::AssertionType>() {
  return ::farm::nurture::core::contracts::common::AssertionType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::GeoDataSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::GeoDataSource>() {
  return ::farm::nurture::core::contracts::common::GeoDataSource_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::FilterKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::FilterKey>() {
  return ::farm::nurture::core::contracts::common::FilterKey_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ReferenceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ReferenceType>() {
  return ::farm::nurture::core::contracts::common::ReferenceType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::AttributeKey> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::AttributeKey>() {
  return ::farm::nurture::core::contracts::common::AttributeKey_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ServiceName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ServiceName>() {
  return ::farm::nurture::core::contracts::common::ServiceName_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ValueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ValueType>() {
  return ::farm::nurture::core::contracts::common::ValueType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ValidationName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ValidationName>() {
  return ::farm::nurture::core::contracts::common::ValidationName_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::ValidationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::ValidationType>() {
  return ::farm::nurture::core::contracts::common::ValidationType_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::HealthParameters> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::HealthParameters>() {
  return ::farm::nurture::core::contracts::common::HealthParameters_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::CloudStore> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::CloudStore>() {
  return ::farm::nurture::core::contracts::common::CloudStore_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::UrlBuilder> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::UrlBuilder>() {
  return ::farm::nurture::core::contracts::common::UrlBuilder_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::Satellite> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::Satellite>() {
  return ::farm::nurture::core::contracts::common::Satellite_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::Band> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::Band>() {
  return ::farm::nurture::core::contracts::common::Band_descriptor();
}
template <> struct is_proto_enum< ::farm::nurture::core::contracts::common::AppName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::farm::nurture::core::contracts::common::AppName>() {
  return ::farm::nurture::core::contracts::common::AppName_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Common_2fgeo_5fenums_2eproto
